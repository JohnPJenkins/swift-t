

////

Swift/T Gallery, asciidoc format
http://swift-lang.org/Swift-T/gallery.html

////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Gallery

This page demonstrates the ease of use of Swift/T when constructing
common application patterns.

Links:

* link:swift.html[General documentation for Swift/T]

* Post to http://lists.mcs.anl.gov/mailman/listinfo/exm-user[the ExM
  user list] with questions about these examples.

* These example scripts may be link:downloads/gallery.tar.gz[downloaded
  here] (2KB).

== Hello world


*File:* +hello-world/hello-world.swift+
----
include::gallery/hello-world/hello-world.swift[]
----


== Swift/T for shell users

Swift/T has a powerful shell interface in its
link:guide.html#app_functions[app function] syntax.  Here are some
advanced examples:

To pass a whole command line into a generic app function, use: 


*File:* +sh-c/sh-1.swift+
----
include::gallery/sh-c/sh-1.swift[]
----


producing:
----
this is my message
----

Programs that are found in different locations on different machines
can be accessed like this: 


*File:* +sh-c/sh-2.swift+
----
include::gallery/sh-c/sh-2.swift[]
----


You can put the "program configuration" section in a separate file and
link:guide.html#modules[+import+] it. 

If you prefer, you could also put separate definitions of +program+ in
separate files and link:guide.html#cpp_macro[conditionally +#include+]
them with STC support for the link:guide.html#cpp[C preprocessor].

This script converts itself to octal in +mtc.octal+.


*File:* +mtc/mtc1.swift+
----
include::gallery/mtc/mtc1.swift[]
----


This script splits itself into lines, where line _i_ is in file +out-+
_i_ +.txt+


*File:* +mtc/mtc2.swift+
----
include::gallery/mtc/mtc2.swift[]
----


Note that each +/bin/echo+ is eligible to run concurrently.  See
link:guide.html#_invocation[Invocation] for how to run with many
processes.

== Swift/T for cluster users

It's easy to launch these kinds of workloads on a cluster.

If using a plain host list:


*File:* +mtc/hosts.txt+
----
include::gallery/mtc/hosts.txt[]
----


Just run with:

----
stc mtc1.swift
turbine -f hosts.txt -n 4 mtc1.tic
----

As shown, +turbine+ accepts an MPI hosts file and number of
processes, just like +mpiexec+.

A shorter, equivalent form of that command sequence is:

----
swift-t -t f:hosts.txt -n 4 mtc1.swift
----

On a PBS system, run with:

----
swift-t -m pbs -n 4 mtc1.swift
----

Many link:turbine-sites.html[other systems] are supported!

== Swift/T for MapReduce users

A simplified version of the MapReduce model is to just compute many
things and assemble them together at the end.

This script splits itself into lines, then reassembles the original
script.


*File:* +mtc/mtc3.swift+
----
include::gallery/mtc/mtc3.swift[]
----


Note that leading whitespace is trimmed by +file_lines()+, and +cat()+
is part of the Swift/T standard library in module +unix+.

== Swift/T for recursive algorithms

This script computes the given
link:https://en.wikipedia.org/wiki/Fibonacci_number[Fibonacci number]:


*File:* +fib/fib.swift+
----
include::gallery/fib/fib.swift[]
----


Run it as:


*File:* +fib/run.sh+
----
include::gallery/fib/run.sh[]
----


The +sys+ module provides the +argv()+ function, which provides a
handy key/value interface for input values.

This script implements a parallel
link:https://en.wikipedia.org/wiki/Merge_sort[merge sort].  The data
files are generated by

----
tclsh make-data.tcl
----

Each of the 8 files is already sorted, and a merged result will be
placed in +sorted.txt+.


*File:* +merge-sort/merge.swift+
----
include::gallery/merge-sort/merge.swift[]
----


This code runs the +sort+ invocations concurrently, limited only by
available processors and data dependencies.

== Swift/T for Python and Numpy users

Swift/T can run Python as an ordinary external program or via a
bundled interpreter!  You can load Python packages, including
Python-wrapped native code- just set +PYTHONPATH+ and +import+ what
you need.

See this section for information about calling Python or Numpy:
link:guide.html#_external_scripting_support[Swift/T Guide: Python]

[[swift_tcl]]
== Swift/T for Tcl users

Swift/T is a great way to parallelize Tcl applications.  You can run
+tclsh+ as an ordinary external program, or use the bundled Tcl
interpreter!  (Swift/T always has a Tcl interpreter for basic
operation.)  You can load Tcl packages, including Tcl-wrapped native
code- just set +SWIFT_PATH+ and +package require+ what you need.


*File:* +swift-tcl/tcl.swift+
----
include::gallery/swift-tcl/tcl.swift[]
----


Run this with:
----
swift-t -p gallery/swift-tcl/tcl.swift
----
(+swift-t -p+ turns off the C preprocessor and allows the triple-quote
syntax.)

It outputs:
----
o should be: 7
tcl: o=7
o is: 7
----

The +@dispatch=WORKER+ annotation allows +add()+ to run on any worker
process in the run.  Multiple +add()+ s, or other functions, can run
concurrently.  Swift automatically maintains ordering by managing data
dependencies from function outputs to inputs.

== Static executables

This section demonstrates a complete, concrete example of the optional
link:guide.html#mkstatic[static executable] feature.  First, compose a
Swift script.


*File:* +static-exec/hello.swift+
----
include::gallery/static-exec/hello.swift[]
----


Then, copy Turbine's example manifest file and edit.
This manifest has all comments removed for simplicity.


*File:* +static-exec/hello.manifest+
----
include::gallery/static-exec/hello.manifest[]
----


Then, build:


*File:* +static-exec/build.sh+
----
include::gallery/static-exec/build.sh[]
----


////
Local Variables:
mode: doc
eval: (auto-fill-mode 1)
End:
////
