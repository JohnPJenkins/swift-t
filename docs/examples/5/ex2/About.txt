Enabling running ordinary C code as Swift/T application on IBM BG-style supercomputers
=======================================================================================

Goal:
Run a user provided C/C++ based application on leadership class systems via Swift.

Motivation:
Since the target computing environment does not allow fork/exec on compute
nodes, an alternative approach is to tightly couple existing codes into the
Swift/T framework and run it as a single piece of parallel code.

The benefit to users is ease of application composability while still being
able to take advantage of high-level expressivity and high performance from
execution.

High-level Workflow:
user-app.c --------> user-app.swift

Detailed process:

Step 1. User writes her C/C++ program.
Step 2. Swift/T cfun module takes up the C/C++ program and replaces "main" with "swift-main"
Step 3. cfun module generates an .SO library from above generated C/C++ program
Step 4. genTCL module generates TCL bindings for C/C++ code
Step 5. User writes Swift code
Step 6. User runs Swift code

About.txt : The current file.

user-app.c  : main program a la application code; passes the args of main to swift-main
swift-main.c : The swift-main code that takes up the application code 
extension.c : Injects an ability to call c function with TCL 
make-package.tcl : Creates and defines TCL package, version, function definitions.
prog-swift.swift : High level Swift script defining 
prog-tcl.tcl : A separate TCL program that calls the swift-main tcl function with commandline args.
swift-main.h : Header file to declare functions defined in Swift main.
swift-main.i : Swig interface definition. Generates C bindings for TCL. In other words, makes it possible to call TCL library and user functions from C.
swift-main.tcl : Auto-generated from ?
Makefile : Make file to generate shared libraries from source code, `make run` compiles and runs the code.
run.sh : run script.

