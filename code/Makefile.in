
TURBINE_VERSION = @TURBINE_VERSION@

PACKAGE = lib/pkgIndex.tcl

all: package

turbine: $(TURBINE)

package: $(PACKAGE)

USE_MAC = @USE_MAC@

INSTALL_PREFIX  = @prefix@
INSTALL_BIN     = $(INSTALL_PREFIX)/bin
INSTALL_LIB     = $(INSTALL_PREFIX)/lib
INSTALL_SCRIPTS = $(INSTALL_PREFIX)/scripts
INSTALL_EXPORT  = $(INSTALL_PREFIX)/export
SCRIPTS_SUBMIT  = $(shell find scripts/submit -name "*sh" )

# Shared object suffix is .so on Linux, .dylib on Mac
# GCC shared library creation argument
# Linux: -shared; Mac: -dynamiclib
# Use -flat_namespace on the Mac
ifeq ($(USE_MAC),no)
# Linux
  SO_SUFFIX = so
  SHARED = -shared
  MAC_FLAT =
  MAC_NAME =
else
# Mac
  SO_SUFFIX = dylib
  MAC_FLAT = -flat_namespace
  MAC_NAME = -install_name $(INSTALL_LIB)/libtclturbine.dylib
  SHARED = -dynamiclib $(MAC_FLAT)
endif

TCL_TURBINE_SO = lib/libtclturbine.$(SO_SUFFIX)

# Used only for testing:
TURBINE_A = lib/libturbine.a

tcl_turbine: $(TCL_TURBINE_SO)

srcdir = @srcdir@

ifeq ($(V),1)
	QUIET_COMPILE = 0
else
	QUIET_COMPILE = 1
endif

ifeq ($(QUIET_COMPILE),1)
  # Prints a short description of the action, does not show command
  Q=@echo
  E=@
else
  # Echoes the entire command
  Q=@echo >/dev/null
  E=
endif

CC = @CC@
CFLAGS := @CFLAGS@

# Set includes
CFLAGS += -I .
# CFLAGS += additional system includes here

C_UTILS = @USE_C_UTILS@

TCL := @USE_TCL@
TCLSH := @USE_TCLSH@
TCL_LIB_DIR := @USE_TCL_LIB_DIR@
TCLSH_LOCAL := @USE_TCLSH_LOCAL@

MACHINE = @USE_MACHINE@

# On some systems, the user will use mpicc,
# on others, the user will specify the MPI include and lib paths
MPI = @USE_MPI@
MPI_INCLUDE = @USE_MPI_INCLUDE@
MPI_LIB_DIR = @USE_MPI_LIB_DIR@
MPI_LIB_NAME = @USE_MPI_LIB_NAME@
# The actual linker arguments:
MPI_LIB :=
ifneq ($(MPI),0)
	CFLAGS += -I $(MPI)/include
endif
ifneq ($(MPI_INCLUDE),0)
	CFLAGS += -I $(MPI_INCLUDE)
endif
ifeq ($(MACHINE),normal)
	MPI_LIB_DIR = $(MPI)/lib
	MPI_LIB_NAME = libmpich.so
	MPI_LIB	= -L$(MPI_LIB_DIR) -l mpich
endif
ifeq ($(MACHINE),sicortex)
	MPI_LIB = -L$(MPI)/lib -l scmpi
endif
ifeq ($(MACHINE),bgp-zeptoos)
	MPI_LIB =
endif
ifeq ($(MACHINE),custom)
	ifneq ($(MPI_LIB_DIR),0)
		MPI_LIB += -L$(MPI_LIB_DIR)
	endif
	ifneq ($(MPI_LIB_NAME),0)
		MPI_LIB += -l $(MPI_LIB_NAME)
	endif
endif

LAUNCH = @USE_LAUNCHER@

ADLB = @USE_ADLB@
ifneq ($(ADLB),0)
	CFLAGS += -I $(ADLB)/include
endif

USE_MPE = @USE_MPE@

CFLAGS += -std=gnu99
CFLAGS += -g
CFLAGS += -Wall
CFLAGS += -I $(C_UTILS)/include
CFLAGS += @TCL_INCLUDE_SPEC@
CFLAGS += -fPIC
# This is referenced in lookup3.c - may want to drop this for speed
CFLAGS += -D VALGRIND
CFLAGS += -D TURBINE_VERSION=\"$(TURBINE_VERSION)\"
ifeq ($(USE_MPE),1)
	CFLAGS += -D ENABLE_MPE
endif

# LIBS: links to ADLB, c-utils, MPE, and MPI
LIBS :=
LIBS += -L$(ADLB)/lib -l adlb
LIBS += -L$(C_UTILS)/lib -l exmcutils
ifeq ($(USE_MPE),1)
	LIBS += -l mpe
endif
LIBS += $(MPI_LIB)

dirname = $(patsubst %/,%,$(dir $(1)))

RPATHS :=
RPATHS += -Wl,-rpath -Wl,$(INSTALL_LIB)
RPATHS += -Wl,-rpath -Wl,$(ADLB)/lib
RPATHS += -Wl,-rpath -Wl,$(C_UTILS)/lib
RPATHS += -Wl,-rpath -Wl,$(MPI_LIB_DIR)
RPATHS += -Wl,-rpath -Wl,$(TCL_LIB_DIR)

### INCLUDES

DIR :=
TURBINE_SRC :=
TCL_TURBINE_SRC :=
include src/turbine/module.mk
include src/util/module.mk
include src/tcl/module.mk
include src/tcl/adlb/module.mk
include src/tcl/turbine/module.mk
include src/tcl/mpe/module.mk

include lib/module.mk

TURBINE_SRC += $(TCL_ADLB_SRC)
TURBINE_SRC += $(TCL_MPE_SRC)

### DEPENDENCIES

TURBINE_DEPS := $(patsubst %.c, %.d, $(TURBINE_SRC) $(TCL_TURBINE_SRC))

TEST_SRC :=
include tests/module.mk
TEST_DEPS := $(patsubst %.c, %.d, $(TEST_SRC))

# Dependency files:
# Remember that having a bad #include can cause dependency
# file generation to fail silently
# Solution: use target check_includes
DEPS := $(TURBINE_DEPS) $(TEST_DEPS)

deps: $(DEPS)

%.d: %.c
	$(Q) "  DEP		$(@)"
	$(E) CC="$(CC)" $(srcdir)/maint/depend.sh \
             $(call dirname, $(*)) $(<) $(@) $(CFLAGS)

ifeq (,$(filter clean deps,$(MAKECMDGOALS)))
 -include $(DEPS)
endif

# Extract all files from *.d files, format and sort:
# Formats to one file per line & extracts junk and extra files in *.d
deps.txt: $(DEPS)
	$(Q) "  DEPS.TXT "
	$(E) $(srcdir)/collect.sh $(@) $(DEPS)

# Check existing *.d files for files that do not exist
# Useful when dependency file generation is failing
# Must "make clean" to re-check correctly
EXISTING_D = $(shell find . -name *.d)

check_includes: deps_contents.txt
	$(Q) "  CHECK.SH"
	$(E) $(srcdir)/maint/check.sh deps_contents.txt

deps_contents.txt:
	$(Q) "  SH		$(@)"
	$(E) $(srcdir)/maint/collect.sh $(@) $(EXISTING_D)

### TAGS

tags: TAGS

TAGS: deps.txt
	$(Q) "  TAGS "
	$(E) etags `cat deps.txt`

### COMPILE

TCL_TURBINE_OBJS += $(patsubst %.c, %.o, $(TCL_TURBINE_SRC))
TURBINE_OBJS = $(patsubst %.c, %.o, $(TURBINE_SRC))

%.o: %.c
# 	The following string produces a false autoscan message (C++)
	$(Q) "  CC		$(@)"
	$(E) $(CC) $(CFLAGS) \
             -c $(<) -o $(@)

### LINK

$(TURBINE_A): $(TURBINE_OBJS)
	$(Q) "  AR		$(@)"
	$(E) install -d lib
	$(E) ar rcs $(@) $(TURBINE_OBJS)

$(TCL_TURBINE_SO): $(TCL_TURBINE_OBJS) $(TURBINE_OBJS)
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(SHARED) -o $(@) \
             $(TCL_TURBINE_OBJS) \
             $(TURBINE_OBJS) \
             $(TCL_LINK_FLAGS) \
             $(LIBS) \
             $(RPATHS) \
             $(MAC_NAME)

### TESTS

# Test cases in C as objects
TEST_OBJS = $(patsubst %.c, %.o, $(TEST_SRC_C))
# Test cases in C as dependency files
TEST_DEPS = $(patsubst %.c, %.d, $(TEST_SRC_C))
# Test cases in C compiled to binary
TEST_BINS = $(patsubst %.c, %.x, $(TEST_SRC_C))
# Test case results
TEST_SCRIPTS = $(patsubst %.c, %.sh, $(TEST_SRC_C))
# Test case outputs
TEST_OUTPUT  := $(patsubst %.c,   %.out, $(TEST_SRC_C))
TEST_OUTPUT  += $(patsubst %.tcl, %.out, $(TEST_SRC_TCL))
# Test case results
TEST_RESULTS := $(patsubst %.c,   %.result, $(TEST_SRC_C))
TEST_RESULTS += $(patsubst %.tcl, %.result, $(TEST_SRC_TCL))

# Target to just build all C tests
tests: $(TEST_BINS)

# Run all tests
test_results: $(TEST_RESULTS)

# Binary executables in the test suite
$(TEST_BINS): %.x: %.o
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(<) \
        $(MAC_FLAT) \
	-L$(INSTALL_LIB) -l tclturbine \
	$(LIBS) \
	$(RPATHS) \
	-o $(@)

# Test result rule for C tests
%.result: %.sh %.x
#       Cannot use chmod in config.status
	$(E) chmod u+x tests/runbin.zsh
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
	$(E) rm -f $(@)
	$(E) $(<) > $(*).tmp 2>&1
	$(E) mv $(*).tmp $(@) 2>&1

# Test result rule for Tcl tests
%.result: %.sh %.tcl $(PACKAGE) bin/turbine install
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
#       Remove old result if present
	$(E) rm -f $(@)
#       Run test script: %.sh
	$(E) LAUNCH=$(LAUNCH) $(<) > $(*).tmp 2>&1
#       Check for valgrind errors
	$(E) ! grep -q "==[0-9]+==" $(*).out
#       Success: create result file
	$(E) mv $(*).tmp $(@)

### INSTALL

HAVE_CP_U = @CP_U@
ifeq ($(HAVE_CP_U),yes)
	CP_ARGS = -uvf
else
	CP_ARGS = -vf
endif

HAVE_CP_PARENTS = @CP_PARENTS@
ifeq ($(HAVE_CP_PARENTS),yes)
	CP_PARENTS = cp --parents
else
	CP_PARENTS = maint/cp-parents.sh
endif

TCL_SO       = libtcl8.5.$(SO_SUFFIX)
EXMCUTILS_SO = libexmcutils.$(SO_SUFFIX)
ADLB_SO      = libadlb.$(SO_SUFFIX)

install: package
	@echo
	$(Q) "  INSTALL: $(INSTALL_PREFIX)"
#       Set up directories
	$(E) mkdir -pv $(INSTALL_PREFIX)
	$(E) mkdir -pv $(INSTALL_LIB)
	$(E) mkdir -pv $(INSTALL_BIN)
	$(E) mkdir -pv $(INSTALL_SCRIPTS)
	$(E) mkdir -pv $(INSTALL_EXPORT)
ifeq ($(USE_MPE),1)
#       We assume libmpe.so is in the ADLB/lib directory
	$(E) cp $(CP_ARGS) $(ADLB)/lib/libmpe.so        $(INSTALL_LIB)
endif
#       Copy Turbine items
	$(E) cp $(CP_ARGS) bin/turbine                  $(INSTALL_BIN)
	$(E) cp $(CP_ARGS) lib/*.tcl                    $(INSTALL_LIB)
	$(E) cp $(CP_ARGS) lib/*.$(SO_SUFFIX)           $(INSTALL_LIB)
	$(E) cp $(CP_ARGS) scripts/*.zsh scripts/*.sh   $(INSTALL_SCRIPTS)
	$(E) $(CP_PARENTS) $(CP_ARGS) $(SCRIPTS_SUBMIT) $(INSTALL_PREFIX)
	$(E) $(CP_PARENTS) $(CP_ARGS) export/*.swift    $(INSTALL_PREFIX)
	$(E) $(CP_PARENTS) $(CP_ARGS) export/**/*.swift $(INSTALL_PREFIX)

### CLEAN

clean::
	@echo
	@echo "  CLEAN"
	@rm -fv  $(TURBINE_A) $(TCL_TURBINE_SO)
	@rm -fv  $(DEPS) $(TEST_DEPS) deps.txt deps_contents.txt TAGS
	@rm -fv  $(TEST_BINS) $(TEST_OBJS) $(TEST_OUTPUT)
	@rm -fv  $(TEST_RESULTS)
	@rm -fv  $(TURBINE_OBJS)
	@rm -fv  $(TCL_TURBINE_OBJS)
	@rm -fvr tests/data

# Clean *.result files that did not succeed
clean-failed:
	@rm -fv `grep -L "exit 0" **/*.result`

.PHONY: clean install package

### DEBUG BUILD SYSTEM

# Useful target when debugging the build system
debug_build:
	@echo DEPS: $(DEPS)
	@echo TURBINE_SRC: $(TURBINE_SRC)
	@echo TURBINE_OBJS: $(TURBINE_OBJS)
	@echo TESTS: $(TESTS)
