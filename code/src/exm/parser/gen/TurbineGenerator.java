/**
 * This module handles the higher-level logic of generating Tcl code.
 * More mechanical aspects of code generation are handled in TclTurbineTree
 * or the classes in the exm.tcl.tree module
 */
package exm.parser.gen;

import java.util.*;

import org.apache.log4j.Logger;

import exm.ast.Builtins.ArithOpcode;
import exm.ast.Builtins.UpdateMode;
import exm.ast.*;
import exm.ast.Types.FunctionType;
import exm.ast.Types.PrimType;
import exm.ast.Types.SwiftType;
import exm.ast.Variable.DefType;
import exm.ast.Variable.VariableStorage;
import exm.parser.CompilerBackend;
import exm.parser.Settings;
import exm.parser.gen.Turbine.StackFrameType;
import exm.parser.ic.ICInstructions.Oparg;
import exm.parser.ic.ICInstructions.OpargType;
import exm.parser.ui.ExitCode;
import exm.parser.util.*;
import exm.tcl.*;

public class TurbineGenerator implements CompilerBackend
{

  private static final String TCLTMP_RANGE_INC = "tcltmp:inc";
  private static final String TCLTMP_RANGE_HI = "tcltmp:hi";
  private static final String TCLTMP_RANGE_LO = "tcltmp:lo";
  private static final String MAIN_FUNCTION_NAME = "__swiftmain";
  private static final String CONSTINIT_FUNCTION_NAME = "__consts";

  /** to avoid clashes with other tcl variables, prefix variables/functions
   * names from swift with these prefixes:
   */
  private static final String COMP_FN_PREFIX = "cmpf:";
  private static final String TCL_LOCAL_TMP_VAR_PREFIX = "l:";
  private static final String TCL_TMP_VAR_PREFIX = "t:";
  private static final String TCL_ALIAS_VAR_PREFIX = "a:";
  private static final String TCL_USER_VAR_PREFIX = "u:";
  private static final String TCL_VALUE_VAR_PREFIX = "v:";
  private static final String TCL_OPT_VALUE_VAR_PREFIX = "optv:";
  private static final String TCL_STRUCT_FIELD_VAR_PREFIX = "sf:";
  private static final String TCL_LOOPINDEX_VAR_PREFIX = "i:";
  private static final String TCL_GLOBAL_CONST_VAR_PREFIX = "c:";
  private static final String TCL_DEREF_COMPILER_VAR_PREFIX = "dr:";
  private static final String TCL_LOOP_INDEX_VAR_PREFIX = "lv:";
  private static final String TCL_OUTER_VAR_PREFIX = "outer:";


  final String timestamp;
  final Logger logger;

  /**
     Our output Tcl
     Convenience reference to bottom of pointStack
   */
  Sequence tree = new Sequence();


  /**
   * For function that initializes globals
   */
  Sequence globInit = new Sequence();

  /**
     Stack for previous values of point
   */
  Deque<Sequence> pointStack = new ArrayDeque<Sequence>();

  /**
   * Stack for name of loop functions
   */
  Deque<String> loopNameStack = new ArrayDeque<String>();

  String turbineVersion = Settings.get(Settings.TURBINE_VERSION);

  HashSet<String> usedTclFunctionNames = new HashSet<String>();

  private static class TCLFunRef {
    public final String pkg;
    public final String symbol;
    public TCLFunRef(String pkg, String symbol) {
      super();
      this.pkg = pkg;
      this.symbol = symbol;
    }
  }
  /**
   * TCL symbol names for builtins
   * Swift function name -> TCL proc name
   */
  private final HashMap<String, TCLFunRef> builtinSymbols =
                      new HashMap<String, TCLFunRef>();

  /**
     If true, enable debug comments in Tcl source
   */
  boolean debuggerComments = false;
  private int foreach_counter = 0;

  public TurbineGenerator(Logger logger, String timestamp)
  {
    this.logger = logger;
    this.timestamp = timestamp;
    pointStack.push(tree);

    if (Settings.get("DEBUGGER") == "COMMENTS")
      debuggerComments = true;
  }

  @Override
  public void header()
  {
    tree.add(new Text(""));
    tree.add(new Comment("generated by parser"));
    tree.add(new Comment("date: " + timestamp));
    tree.add(new Text(""));

    tree.add(new Command("package require turbine", turbineVersion));
    tree.add(new Command("namespace import turbine::*"));
    tree.add(new Text(""));

    Proc globInitProc = new Proc(CONSTINIT_FUNCTION_NAME, usedTclFunctionNames,
                              new ArrayList<String>(), globInit);
    globInit.add(Turbine.turbineLog("function:"+CONSTINIT_FUNCTION_NAME));
    tree.add(globInitProc);
  }

  @Override
  public void turbineStartup()
  {
    tree.add(new Command("turbine::defaults"));
    tree.add(new Command("turbine::init $engines $servers"));
    tree.add(new Command("turbine::start " + MAIN_FUNCTION_NAME +
                                        " " + CONSTINIT_FUNCTION_NAME));
    tree.add(new Command("turbine::finalize"));
  }

  @Override
  public void declare(SwiftType t, String name, VariableStorage storage,
        DefType defType, String mapping)
  throws UndefinedTypeException
  {
    assert(mapping == null || Types.isMappable(t));
    assert(mapping != null || (!Types.requiresMapping(t)));
    String tclName = prefixVar(name);
    Sequence point = pointStack.peek();

    if (storage == VariableStorage.ALIAS) {
      point.add(new Comment("Alias " + name + " with type " + t.toString() +
          " was defined"));
      return;
    }

    if (storage == VariableStorage.GLOBAL_CONST) {
      // If global, it should already be in TCL global scope, just need to
      // make sure that we've imported it
      point.add(Turbine.makeTCLGlobal(tclName));
      return;
    }


    // Initialize the TD in ADLB with a type
    if (Types.isScalarFuture(t) || Types.isScalarUpdateable(t)) {
      if (Types.isFile(t)) {
        point.add(new SetVariable(tclName,
            new Square( new Token("turbine::allocate_file"),
                new Token(tclName), new TclString(mapping, true))));
      } else {
        PrimType pt = t.getPrimitiveType();
        String tprefix = typeToString(pt);
        point.add(Turbine.allocate(tclName, tprefix));
      }
    } else if (Types.isArray(t)) {
      point.add(Turbine.allocateContainer(tclName, Turbine.INTEGER_TPREFIX));
    } else if (Types.isReference(t)) {
      point.add(Turbine.allocate(tclName, Turbine.INTEGER_TPREFIX));
    } else if (Types.isStruct(t)) {
      point.add(Turbine.allocateContainer(tclName, Turbine.STRING_TPREFIX));
    } else if (Types.isScalarValue(t)) {
      if (storage != VariableStorage.LOCAL) {
        throw new ParserRuntimeException("Expected scalar value to have "
            + "local storage");
      }
      point.add(new Comment("Value " + name + " with type " + t.toString() +
          " was defined"));
      // don't need to do anything
    } else {
      throw new ParserRuntimeException("Code generation only implemented" +
          " for initialisation of scalar, reference, array and struct types");
    }


    // Store the name->TD in the stack

      if (storage == VariableStorage.STACK && !noStackVars()) {
        Command s = Turbine.storeInStack(name, tclName);
        // Store the name->TD in the stack
        point.add(s);
      }

  }

  @Override
  public void closeArray(Variable arr) {
    SwiftType type = arr.getType();
    assert(Types.isArray(type));
    // Close array by removing the slot we created at startup
    pointStack.peek().add(Turbine.containerSlotDrop(varToExpr(arr)));
  }

  String typeToString(PrimType type)
  throws UndefinedTypeException
  {
    switch(type) {
    case INTEGER:
      return Turbine.INTEGER_TPREFIX;
    case STRING:
      return Turbine.STRING_TPREFIX;
    case FLOAT:
      return Turbine.FLOAT_TPREFIX;
    case BOOLEAN:
      return Turbine.INTEGER_TPREFIX;
    case VOID:
      return Turbine.VOID_TPREFIX;
    case BLOB:
      return Turbine.BLOB_TPREFIX;
    default:
      // If we did not find the type, fail
      throw new ParserRuntimeException("generator: unknown type: " + type);
    }
  }

  /**
   * Set target=addressof(src)
   */
  @Override
  public void assignReference(Variable target, Variable src) {
    assert(Types.isReference(target.getType()));
    assert(target.getType().getMemberType().equals(src.getType()));
    pointStack.peek().add(Turbine.integerSet(
          prefixVar(target.getName()), varToExpr(src)));
  }


  @Override
  public void makeAlias(Variable dst, Variable src) {
    assert(src.getType().equals(dst.getType()));
    assert(dst.getStorage() == VariableStorage.ALIAS);
    pointStack.peek().add(new SetVariable(prefixVar(dst.getName()),
        varToExpr(src)));
  }

  @Override
  public void assignInt(Variable target, Oparg src) {
    assert(src.isImmediateInt());
    if (!Types.isInt(target.getType())) {
      throw new ParserRuntimeException("Expected variable to be int, "
          + " but was " + target.getType().toString());
    }

    pointStack.peek().add(Turbine.integerSet(
                              prefixVar(target.getName()),
                              opargToExpr(src)));
  }

  @Override
  public void retrieveInt(Variable target, Variable source) {
    assert(target.getType().equals(Types.VALUE_INTEGER));
    assert(source.getType().equals(Types.FUTURE_INTEGER));
    pointStack.peek().add(Turbine.integerGet(prefixVar(target.getName()),
                                                varToExpr(source)));
  }



  @Override
  public void assignBool(Variable target, Oparg src) {
    assert(src.isImmediateBool());
    if (!Types.isBool(target.getType())) {
      throw new ParserRuntimeException("Expected variable to be bool, "
          + " but was " + target.getType().toString());
    }

    pointStack.peek().add(Turbine.integerSet(
                             prefixVar(target.getName()),
                             opargToExpr(src)));
  }

  @Override
  public void retrieveBool(Variable target, Variable source) {
    assert(target.getType().equals(Types.VALUE_BOOLEAN));
    assert(source.getType().equals(Types.FUTURE_BOOLEAN));
    pointStack.peek().add(Turbine.integerGet(prefixVar(target.getName()),
        varToExpr(source)));
  }


  @Override
  public void assignFloat(Variable target, Oparg src) {
    assert(src.isImmediateFloat());
    if (!Types.isFloat(target.getType())) {
      throw new ParserRuntimeException("Expected variable to be float, "
          + " but was " + target.getType().toString());
    }

    pointStack.peek().add(Turbine.floatSet(
                              prefixVar(target.getName()),
                              opargToExpr(src)));
  }

  @Override
  public void retrieveFloat(Variable target, Variable source) {
    assert(target.getType().equals(Types.VALUE_FLOAT));
    assert(source.getType().equals(Types.FUTURE_FLOAT));
    pointStack.peek().add(Turbine.floatGet(prefixVar(target.getName()),
                                                  varToExpr(source)));
  }

  @Override
  public void assignString(Variable target, Oparg src) {
    assert(src.isImmediateString());
    if (!Types.isString(target.getType())) {
      throw new ParserRuntimeException("Expected variable to be string, "
          + " but was " + target.getType().toString());
    }

    pointStack.peek().add(Turbine.stringSet(prefixVar(target.getName()),
                                                opargToExpr(src)));
  }

  @Override
  public void retrieveString(Variable target, Variable source) {
    assert(target.getType().equals(Types.VALUE_STRING));
    assert(source.getType().equals(Types.FUTURE_STRING));
    pointStack.peek().add(Turbine.stringGet(prefixVar(target.getName()),
                                                    varToExpr(source)));
  }

  @Override
  public void localArithOp(ArithOpcode op, Variable out,
                                            List<Oparg> in) {
    ArrayList<Expression> argExpr = new ArrayList<Expression>(in.size());
    for (Oparg a: in) {
      argExpr.add(opargToExpr(a));
    }

    if (op == ArithOpcode.ASSERT || op == ArithOpcode.ASSERT_EQ ||
        op == ArithOpcode.TRACE) {
      assert(out == null);
      String tclFn;
      switch (op) {
      case ASSERT:
        tclFn = "turbine::assert_impl";
        break;
      case ASSERT_EQ:
        tclFn = "turbine::assertEqual_impl";
        break;
      case TRACE:
        tclFn = "turbine::trace_impl";
        break;
      default:
        throw new ParserRuntimeException("Cn't handle local op: "
            + op.toString());
      }
      Command cmd = new Command(tclFn, argExpr);
      pointStack.peek().add(cmd);
      return;
    } else if (op == ArithOpcode.ARGC_GET || op == ArithOpcode.ARGV_CONTAINS
            || op == ArithOpcode.ARGV_GET) {
      assert(out != null);
      String tclFn;
      switch (op) {
      case ARGC_GET:
        tclFn = "turbine::argc_get_impl";
        break;
      case ARGV_CONTAINS:
        tclFn = "turbine::argv_contains_impl";
        break;
      case ARGV_GET:
        tclFn = "turbine::argv_get_impl";
        break;
      default:
        throw new ParserRuntimeException("Cn't handle local op: "
            + op.toString());
      }
      SetVariable cmd = new SetVariable(prefixVar(out.getName()), 
                        Square.fnCall(tclFn, argExpr.toArray(
                            new Expression[argExpr.size()])));
      pointStack.peek().add(cmd);
      return;
    } else if (op == ArithOpcode.PRINTF || op == ArithOpcode.SPRINTF) {
      Square fmtArgs = new TclList(argExpr);
      Square fmt = new Square(new Token("eval"), new Token("format"), 
                                                                fmtArgs);
      if (op ==  ArithOpcode.PRINTF) {
        pointStack.peek().add(new Command(new Token("puts"), fmt));
      } else {
        assert(op == ArithOpcode.SPRINTF);
        pointStack.peek().add(new SetVariable(prefixVar(out.getName()), fmt));
      }
      return;
    } else {
      assert(out != null);
      assert(Types.isScalarValue(out.getType()));
      Expression rhs;
      // First handle special cases, then typical case
      if (op == ArithOpcode.STRCAT) {
        rhs = localStrCat(in, argExpr);
      } else if (op == ArithOpcode.EQ_STRING
                || op == ArithOpcode.NEQ_STRING) {
        assert(argExpr.size() == 2);
        rhs = new Square(new Token("string"), new Token("equal"),
            argExpr.get(0), argExpr.get(1));
        if (op == ArithOpcode.NEQ_STRING) {
          // Negate previous result
          rhs = Square.arithExpr(new Token("!"), rhs);
        }
      } else if (op == ArithOpcode.COPY_BLOB ||
          op ==  ArithOpcode.COPY_BOOL ||
          op == ArithOpcode.COPY_INT ||
          op == ArithOpcode.COPY_FLOAT ||
          op == ArithOpcode.COPY_STRING) {
        assert(argExpr.size() == 1);
        checkCopy(op, out, in.get(0));
        rhs = argExpr.get(0);
      } else if (op == ArithOpcode.MOD_INT) {
        // Special implementation to emulate old swift
        rhs = Turbine.modInteger(argExpr.get(0), argExpr.get(1));
      } else if (op == ArithOpcode.DIV_INT) {
        // special implementation to emulate old swift
        rhs = Turbine.divideInteger(argExpr.get(0), argExpr.get(1));
      } else if (op == ArithOpcode.RAND_INT) {
        rhs = new Square(new Token("turbine::randint_impl"), argExpr.get(0),
                                                    argExpr.get(1));
      } else if (op == ArithOpcode.POW_INT) {
        assert(argExpr.size() == 2);
        assert(in.get(0).isImmediateInt() && in.get(1).isImmediateInt());
        rhs = new Square(new Token("turbine::pow_integer_impl"), argExpr.get(0),
                                                                argExpr.get(1));
      } else if (op == ArithOpcode.SUBSTRING) {
        assert(argExpr.size() == 3);
        rhs = new Square(new Token("turbine::substring_impl"),
            argExpr.get(0), argExpr.get(1), argExpr.get(2));
      } else if (op == ArithOpcode.INTTOSTR || op == ArithOpcode.FLOATTOSTR) {
        assert(argExpr.size() == 1);
        // TCL will convert automatically
        rhs = argExpr.get(0);
      } else if (op == ArithOpcode.STRTOINT ||
          op == ArithOpcode.STRTOFLOAT ) {
        assert(argExpr.size() == 1);
        String tclCheck = (op == ArithOpcode.STRTOINT) ?
                  "turbine::check_str_int" : "turbine::check_str_float";
        rhs = Square.fnCall(tclCheck, argExpr.get(0));


      } else {
        // Case for operations that are implemented directly with
        // TCL's expr
        Expression exp[] = arithOpExpr(op, argExpr);
        rhs = Square.arithExpr(exp);
      }
      SetVariable sv = new SetVariable(prefixVar(out.getName()),
          rhs);
      pointStack.peek().add(sv);
    }
  }

  private void checkCopy(ArithOpcode op, Variable out, Oparg inArg) {
    SwiftType expType = null;
    switch (op) {
    case COPY_BLOB:
      expType = Types.VALUE_BLOB;
      break;
    case COPY_BOOL:
      expType = Types.VALUE_BOOLEAN;
      break;
    case COPY_FLOAT:
      expType = Types.VALUE_FLOAT;
      break;
    case COPY_INT:
      expType = Types.VALUE_INTEGER;
      break;
    case COPY_STRING:
      expType = Types.VALUE_STRING;
      break;
    }
    if (inArg.getType() == OpargType.VAR) {
      assert(expType.equals(inArg.getSwiftType()));
    } else {
      // getSwiftType returns futures for constant vals
      assert(expType.getPrimitiveType()
          == inArg.getSwiftType().getPrimitiveType());
    }
    assert(expType.equals(out.getType()));
  }

  private Expression localStrCat(List<Oparg> in, ArrayList<Expression> argExpr) {
    TclString rhs = new TclString("", false);
    for (Expression e: argExpr) {
      rhs.add(e);
    }
    return rhs;
  }

  private Expression[] arithOpExpr(ArithOpcode op,
                        ArrayList<Expression> argExpr) {
    switch(op) {
    /* First handle binary ops that map nicely to TCL equivalent */
    case PLUS_INT: case PLUS_FLOAT:
    case MINUS_INT: case MINUS_FLOAT:
    case MULT_INT: case MULT_FLOAT:
    case DIV_FLOAT: case POW_FLOAT:
    case EQ_INT: case NEQ_INT:
    case LT_INT: case LTE_INT: case GT_INT: case GTE_INT:
    case LT_FLOAT: case LTE_FLOAT: case GT_FLOAT: case GTE_FLOAT:
    case EQ_FLOAT: case NEQ_FLOAT:
    case EQ_BOOL: case NEQ_BOOL:
    case EQ_STRING: case NEQ_STRING:
    case AND: case OR:

      assert(argExpr.size() == 2);
      return new Expression[] {
          argExpr.get(0), arithOpTok(op), argExpr.get(1)
          };
    case NOT: case NEGATE_INT: case NEGATE_FLOAT:

      /* next unary ops with tcl equivalent */
      assert(argExpr.size() == 1);
      return new Expression[] {
          arithOpTok(op), argExpr.get(0)
          };
    case IS_NAN:
      assert(argExpr.size() == 1);
      return new Expression[] {
          argExpr.get(0), new Token("!="), argExpr.get(0)};
    case CEIL: case FLOOR: case ROUND:
    case LOG: case EXP: case SQRT:
    case ABS_FLOAT: case ABS_INT:
      // Single argument to expr function
      return new Expression[] {
          arithOpTok(op), new Token("("), argExpr.get(0),
          new Token(")")
          };
    case RANDOM:
      // No arguments to expr function
      return new Expression[] {
          arithOpTok(op), new Token("()")
          };
    case INTTOFLOAT:
      assert(argExpr.size() == 1);
      return new Expression[] { argExpr.get(0) };
    case MAX_FLOAT: case MAX_INT: case MIN_FLOAT: case MIN_INT:
      String fnName;
      if (op == ArithOpcode.MAX_FLOAT || op == ArithOpcode.MAX_INT) {
        fnName = "max";
      } else {
        fnName = "min";
      }
      return new Expression[] {new Token(fnName), new Token("("),
                     argExpr.get(0),
                     new Token(","), argExpr.get(1), new Token(")")};
    default:
      throw new ParserRuntimeException("Haven't implement code gen for "
          + "local arithmetic op " + op.toString());
    }
  }

  private Token arithOpTok(ArithOpcode op) {
    switch (op) {
    case EQ_INT: case EQ_FLOAT: case EQ_BOOL:
      return new Token("==");
    case NEQ_INT: case NEQ_FLOAT: case NEQ_BOOL:
      return new Token("!=");
    case PLUS_INT:
    case PLUS_FLOAT:
      return new Token("+");
    case MINUS_INT:
    case MINUS_FLOAT:
    case NEGATE_INT:
    case NEGATE_FLOAT:
      return new Token("-");
    case MULT_FLOAT:
    case MULT_INT:
      return new Token("*");
    case POW_FLOAT:
      return new Token("**");
    case LT_INT: case LT_FLOAT:
      return new Token("<");
    case LTE_INT: case LTE_FLOAT:
      return new Token("<=");
    case GT_INT: case GT_FLOAT:
      return new Token(">");
    case GTE_INT: case GTE_FLOAT:
      return new Token(">=");
    case OR:
      return new Token("||");
    case AND:
      return new Token("&&");
    case NOT:
      return new Token("!");
    case CEIL:
      return new Token("ceil");
    case FLOOR:
      return new Token("floor");
    case ROUND:
      return new Token("round");
    case EXP:
      return new Token("exp");
    case LOG:
      return new Token("log");
    case SQRT:
      return new Token("sqrt");
    case ABS_FLOAT: case ABS_INT:
      return new Token("abs");
    case RANDOM:
      return new Token("rand");
    case DIV_FLOAT:
      return new Token("/");
    default:
      throw new ParserRuntimeException("need to add op " +
                op.toString());
    }
  }


  @Override
  public void dereferenceInt(Variable target, Variable src) {
    assert(target.getType().equals(Types.FUTURE_INTEGER));
    assert(src.getType().equals(Types.REFERENCE_INTEGER));
    Sequence deref = Turbine.dereferenceInteger(prefixVar(target.getName()),
        prefixVar(src.getName()));
    pointStack.peek().add(deref);
  }

  @Override
  public void dereferenceBool(Variable target, Variable src) {
    assert(target.getType().equals(Types.FUTURE_BOOLEAN));
    assert(src.getType().equals(Types.REFERENCE_BOOLEAN));
    Sequence deref = Turbine.dereferenceInteger(prefixVar(target.getName()),
        prefixVar(src.getName()));
    pointStack.peek().add(deref);
  }

  @Override
  public void dereferenceFloat(Variable target, Variable src) {
    assert(target.getType().equals(Types.FUTURE_FLOAT));
    assert(src.getType().equals(Types.REFERENCE_FLOAT));
    Sequence deref = Turbine.dereferenceFloat(prefixVar(target.getName()),
        prefixVar(src.getName()));
    pointStack.peek().add(deref);
  }

  @Override
  public void dereferenceString(Variable target, Variable src) {
    assert(target.getType().equals(Types.FUTURE_STRING));
    assert(src.getType().equals(Types.REFERENCE_STRING));
    Sequence deref = Turbine.dereferenceString(prefixVar(target.getName()),
        prefixVar(src.getName()));
    pointStack.peek().add(deref);
  }

  @Override
  public void dereferenceBlob(Variable target, Variable src) {
    assert(target.getType().equals(Types.FUTURE_BLOB));
    assert(src.getType().equals(Types.REFERENCE_BLOB));
    Sequence deref = null;
    pointStack.peek().add(deref);
    //TODO
    throw new ParserRuntimeException("TODO: dereferenceBlob");
  }

  @Override
  public void retrieveRef(Variable target, Variable src) {
    assert(Types.isReference(src.getType()));
    assert(Types.isReferenceTo(src.getType(), target.getType()));
    TclTree deref = Turbine.integerGet(prefixVar(target.getName()),
                                                   varToExpr(src));
    pointStack.peek().add(deref);
  }

  @Override
  public void arrayCreateNestedComputedIndex(Variable arrayResult,
      Variable arrayVar, Variable indexVar) {
    assert(Types.isArray(arrayVar.getType()));
    assert(Types.isArrayRef(arrayResult.getType()));
    assert(arrayResult.getStorage() == VariableStorage.ALIAS);

    TclTree t = Turbine.containerCreateNested(
        prefixVar(arrayResult.getName()), prefixVar(arrayVar.getName()),
        prefixVar(indexVar.getName()));
    pointStack.peek().add(t);
  }

  @Override
  public void arrayRefCreateNestedComputedIndex(Variable arrayResult,
      Variable arrayRefVar, Variable indexVar) {
    assert(Types.isArrayRef(arrayRefVar.getType()));
    assert(Types.isArrayRef(arrayResult.getType()));
    assert(arrayResult.getStorage() == VariableStorage.ALIAS);

    TclTree t = Turbine.containerRefCreateNested(
        prefixVar(arrayResult.getName()), prefixVar(arrayRefVar.getName()),
        prefixVar(indexVar.getName()));
    pointStack.peek().add(t);
  }


  @Override
  public void arrayCreateNestedImmediate(Variable arrayResult,
      Variable arrayVar, Oparg arrIx) {
    assert(Types.isArray(arrayVar.getType()));
    assert(Types.isArray(arrayResult.getType()));
    assert(arrayResult.getStorage() == VariableStorage.ALIAS);
    assert(arrIx.isImmediateInt());

    TclTree t = Turbine.containerCreateNestedImmIx(
        prefixVar(arrayResult.getName()), prefixVar(arrayVar.getName()),
        opargToExpr(arrIx));
    pointStack.peek().add(t);
  }

  @Override
  public void arrayRefCreateNestedImmediateIx(Variable arrayResult,
      Variable arrayVar, Oparg arrIx) {
    assert(Types.isArrayRef(arrayVar.getType()));
    assert(Types.isArrayRef(arrayResult.getType()));
    assert(arrayResult.getStorage() == VariableStorage.ALIAS);
    assert(arrIx.isImmediateInt());

    TclTree t = Turbine.containerRefCreateNestedImmIx(
        prefixVar(arrayResult.getName()), prefixVar(arrayVar.getName()),
        opargToExpr(arrIx));
    pointStack.peek().add(t);
  }
  /** NOT UPDATED */

  @Override
  public void appFunctionCall(String function,
                              List<Variable> inputs,
                              List<Variable> outputs)
  {
    throw new ParserRuntimeException("appFunctionCall not implemented");
    //    logger.debug("call app: " + function);
    //    String iString = listOfTclVariables(inputs);
    //    String oString = listOfTclVariables(outputs);
    //    return function + " " + oString + " " + iString + '\n';
  }

  @Override
  public void builtinFunctionCall(String function,
                                  List<Variable> inputs,
                                  List<Variable> outputs)
  {
    logger.debug("call builtin: " + function);
    //    String iString = listOfTclVariables(inputs);
    //    String oString = listOfTclVariables(outputs);
    //    Tok"turbine::"+function + " " +
    //           oString + " " + iString + '\n';

    TclList iList = tclListOfVariables(inputs);
    TclList oList = tclListOfVariables(outputs);
    // return function + " $stack " + oString + " " + iString + '\n';
    TCLFunRef tclf = builtinSymbols.get(function);
    if (tclf == null) {
      //should have all builtins in symbols
      throw new ParserRuntimeException("call to undefined builtin function "
          + function);
    }
    Token f = new Token(tclf.pkg + "::" + tclf.symbol);
    Value s = new Value(Turbine.LOCAL_STACK_NAME);
    Command c = new Command(f, s, oList, iList);
    pointStack.peek().add(c);
  }

  @Override
  public void compositeFunctionCall(String function,
                                    List<Variable> inputs,
                                    List<Variable> outputs,
                                    List<Boolean> blocking,
                                    boolean async)
  {
    logger.debug("call composite: " + function);
    TclList iList = tclListOfVariables(inputs);
    TclList oList = tclListOfVariables(outputs);
    ArrayList<Variable> blockOn = new ArrayList<Variable>();
    HashSet<String> alreadyBlocking = new HashSet<String>();
    for (int i = 0; i < inputs.size(); i++) {
      Variable v = inputs.get(i);
      if (blocking.get(i) && !alreadyBlocking.contains(v.getName())) {
        blockOn.add(v);
        alreadyBlocking.add(v.getName());
      }
    }
    if (async) {
      pointStack.peek().add(Turbine.callComposite(COMP_FN_PREFIX + function,
                            oList, iList, tclListOfVariables(blockOn)));
    } else {
      // Calling synchronously, can't guarantee anything blocks
      assert(blocking.size() == 0);
      pointStack.peek().add(Turbine.callCompositeSync(COMP_FN_PREFIX + function,
          oList, iList));
    }
  }

  @Override
  public void structInsert(Variable structVar, String fieldName,
      Variable fieldContents) {
    pointStack.peek().add(
        Turbine.structInsert(prefixVar(structVar.getName()),
            fieldName, prefixVar(fieldContents.getName())));
  }

  /**
   * Called once all fields have been added to struct
   * @param struct
   */
  @Override
  public void structClose(Variable struct) {
    pointStack.peek().add(
        Turbine.containerSlotDrop(varToExpr(struct)));
  }

  /**
   * load the turbine id of the field into alias
   * @param structVar
   * @param structField
   * @param alias
   */
  @Override
  public void structLookup(Variable structVar, String structField,
        Variable alias) {
    pointStack.peek().add(
        Turbine.structLookupFieldID(prefixVar(structVar.getName()),
            structField, prefixVar(alias.getName())));
  }

  @Override
  public void structRefLookup(Variable structVar, String structField,
        Variable alias) {
    pointStack.peek().add(
        Turbine.structRefLookupFieldID(prefixVar(structVar.getName()),
            structField, prefixVar(alias.getName())));
  }


  @Override
  public void arrayLoadComputedIndex(Variable oVar, Variable arrayVar, Variable indexVar,
        boolean isArrayRef) {
    arrayLoadCheckTypes(oVar, arrayVar, isArrayRef);
    assert(indexVar.getType().equals(Types.FUTURE_INTEGER));
    assert(Types.isReference(oVar.getType()));
    // Nested arrays - oVar should be a reference type
    Sequence getRef = Turbine.arrayLookupComputed(
        prefixVar(oVar.getName()),
        prefixVar(arrayVar.getName()), prefixVar(indexVar.getName()), isArrayRef);
    pointStack.peek().add(getRef);
  }

  @Override
  public void arrayLoadImmediateIx(Variable oVar, Variable arrayVar, Oparg arrIx,
        boolean isArrayRef) {
    assert(arrIx.isImmediateInt());
    arrayLoadCheckTypes(oVar, arrayVar, isArrayRef);
    Sequence getRef = Turbine.arrayLookupImmIx(
          prefixVar(oVar.getName()),
          prefixVar(arrayVar.getName()),
          opargToExpr(arrIx), isArrayRef);

    pointStack.peek().add(getRef);
  }

  @Override
  public void arrayLoadImmediate(Variable oVar, Variable arrayVar,
                                                      Oparg arrIx) {
    assert(arrIx.isImmediateInt());
    assert(oVar.getType().equals(
                      Types.getArrayMemberType(arrayVar.getType())));
     pointStack.peek().add(Turbine.arrayLookupImm(
         prefixVar(oVar.getName()),
         prefixVar(arrayVar.getName()),
         opargToExpr(arrIx)));
  }

  /**
   * Make sure that types are valid for array load invocation
   * @param oVar The variable the result of the array should go into
   * @param arrayVar
   * @param isReference
   * @return the member type of the array
   */
  private SwiftType arrayLoadCheckTypes(Variable oVar, Variable arrayVar,
      boolean isReference) {
    SwiftType memberType;
    // Check that the types of the array variable are correct
    if (isReference) {
      assert(Types.isArrayRef(arrayVar.getType()));
      SwiftType arrayType = arrayVar.getType().getMemberType();
      assert(Types.isArray(arrayType));
      memberType = arrayType.getMemberType();
    } else {
      assert(Types.isArray(arrayVar.getType()));
      memberType = arrayVar.getType().getMemberType();
    }


    SwiftType oType = oVar.getType();
    if (!Types.isReference(oType)) {
      throw new ParserRuntimeException("Output variable for " +
          "array lookup should be a reference " +
          " but had type " + oType.toString());
    }
    if (!oType.getMemberType().equals(memberType)) {
      throw new ParserRuntimeException("Output variable for "
          +" array lookup should be reference to "
          + memberType.toString() + ", but was reference to"
          + oType.getMemberType().toString());
    }

    return memberType;
  }

  @Override
  public void arrayStoreComputedIndex(Variable iVar, Variable arrayVar,
                                                      Variable indexVar) {
    assert(Types.isArray(arrayVar.getType()));
    SwiftType memberType = arrayVar.getType().getMemberType();
    if (Types.isReference(iVar.getType())) {
      assert(iVar.getType().getMemberType().equals(memberType));
      Sequence r = Turbine.arrayDerefStoreComputed(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          prefixVar(indexVar.getName()));

      pointStack.peek().add(r);
    } else {
      assert(iVar.getType().equals(memberType));
      Sequence r = Turbine.arrayStoreComputed(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          prefixVar(indexVar.getName()));

      pointStack.peek().add(r);
    }
  }

  @Override
  public void arrayRefStoreComputedIndex(Variable iVar, Variable arrayVar,
                                Variable indexVar, Variable outerArrayVar) {
    assert(Types.isArrayRef(arrayVar.getType()));
    assert(Types.isArray(outerArrayVar.getType()));
    assert(Types.isInt(indexVar.getType()));
    SwiftType memberType = arrayVar.getType().getMemberType().getMemberType();
    if (Types.isReference(iVar.getType())) {
      assert(iVar.getType().getMemberType().equals(memberType));
      Sequence r = Turbine.arrayRefDerefStoreComputed(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          prefixVar(indexVar.getName()), prefixVar(outerArrayVar.getName()));

      pointStack.peek().add(r);
    } else {
      assert(iVar.getType().equals(memberType));
      Sequence r = Turbine.arrayRefStoreComputed(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          prefixVar(indexVar.getName()), prefixVar(outerArrayVar.getName()));

      pointStack.peek().add(r);
    }
  }


  @Override
  public void arrayStoreImmediate(Variable iVar, Variable arrayVar,
        Oparg arrIx) {
    assert(Types.isArray(arrayVar.getType()));
    if (!arrIx.isImmediateInt()) {
      throw new ParserRuntimeException("Not immediate int: " + arrIx);
    }
    assert(arrIx.isImmediateInt());

    SwiftType memberType = arrayVar.getType().getMemberType();
    if (Types.isReference(iVar.getType())) {
      // Check that we get the right thing when we dereference it
      if (!iVar.getType().getMemberType().equals(memberType)) {
        throw new ParserRuntimeException("Type mismatch when trying to store " +
            "from variable " + iVar.toString() + " into array " + arrayVar.toString());
      }
      Sequence r = Turbine.arrayDerefStore(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          opargToExpr(arrIx));
      pointStack.peek().add(r);
    } else {
      if (!iVar.getType().equals(memberType)) {
        throw new ParserRuntimeException("Type mismatch when trying to store " +
            "from variable " + iVar.toString() + " into array " + arrayVar.toString());
      }
      Sequence r = Turbine.arrayStoreImmediate(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          opargToExpr(arrIx));
      pointStack.peek().add(r);
    }
  }

  @Override
  public void arrayRefStoreImmediateIx(Variable iVar, Variable arrayVar,
        Oparg arrIx, Variable outerArrayVar) {
    assert(Types.isArrayRef(arrayVar.getType()));
    assert(Types.isArray(outerArrayVar.getType()));
    assert(arrIx.isImmediateInt());

    SwiftType memberType = arrayVar.getType().getMemberType().getMemberType();
    if (Types.isReference(iVar.getType())) {
      // Check that we get the right thing when we dereference it
      if (!iVar.getType().getMemberType().equals(memberType)) {
        throw new ParserRuntimeException("Type mismatch when trying to store " +
            "from variable " + iVar.toString() + " into array " + arrayVar.toString());
      }
      Sequence r = Turbine.arrayRefDerefStore(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          opargToExpr(arrIx), prefixVar(outerArrayVar.getName()));
      pointStack.peek().add(r);
    } else {
      if (!iVar.getType().equals(memberType)) {
        throw new ParserRuntimeException("Type mismatch when trying to store " +
            "from variable " + iVar.toString() + " into array " + arrayVar.toString());
      }
      Sequence r = Turbine.arrayRefStoreImmediate(
          prefixVar(iVar.getName()), prefixVar(arrayVar.getName()),
          opargToExpr(arrIx), prefixVar(outerArrayVar.getName()));
      pointStack.peek().add(r);
    }
  }

  @Override
  public void initUpdateable(Variable updateable, Oparg val) {
    assert(Types.isScalarUpdateable(updateable.getType()));
    if (!updateable.getType().equals(Types.UPDATEABLE_FLOAT)) {
      throw new ParserRuntimeException(updateable.getType() +
          " not yet supported");
    }
    assert(val.isImmediateFloat());
    pointStack.peek().add(Turbine.floatSet(prefixVar(updateable.getName()), 
                                                         opargToExpr(val)));
  } 

  @Override
  public void latestValue(Variable result, Variable updateable) {
    assert(Types.isScalarUpdateable(updateable.getType()));
    assert(Types.isScalarValue(result.getType()));
    assert(updateable.getType().getPrimitiveType() ==
                  result.getType().getPrimitiveType());
    if (!updateable.getType().equals(Types.UPDATEABLE_FLOAT)) {
      throw new ParserRuntimeException(updateable.getType().typeName()
              + " not yet supported");
    }
    // just get the value the same as any other float future 
    pointStack.peek().add(Turbine.floatGet(prefixVar(result.getName()), 
                                    varToExpr(updateable)));
  }

  @Override
  public void update(Variable updateable, UpdateMode updateMode, Variable val) {
    assert(Types.isScalarUpdateable(updateable.getType()));
    assert(Types.isScalarFuture(val.getType()));
    assert(updateable.getType().getPrimitiveType() ==
                             val.getType().getPrimitiveType());
    assert(updateMode != null);
    String builtinName = getUpdateBuiltin(updateMode);
    pointStack.peek().add(new Command(builtinName, Arrays.asList(
                  (Expression)varToExpr(updateable), varToExpr(val))));
  }

  private String getUpdateBuiltin(UpdateMode updateMode) {
    String builtinName;
    switch(updateMode) {
    case INCR:
      builtinName = "turbine::update_incr";
      break;
    case MIN:
      builtinName = "turbine::update_min";
      break;
    case SCALE:
      builtinName = "turbine::update_scale";
      break;
    default:
      throw new ParserRuntimeException("Unknown UpdateMode: " + updateMode);
    }
    return builtinName;
  }

  @Override
  public void updateImm(Variable updateable, UpdateMode updateMode,
                                                Oparg val) {
    assert(Types.isScalarUpdateable(updateable.getType()));
    if (updateable.getType().equals(Types.UPDATEABLE_FLOAT)) {
      assert(val.isImmediateFloat());
    } else {
      throw new ParserRuntimeException("only updateable floats are"
          + " implemented so far");
    }
    assert(updateMode != null);
    String builtinName = getUpdateBuiltin(updateMode) + "_impl";
    pointStack.peek().add(new Command(builtinName, Arrays.asList(
        (Expression)varToExpr(updateable), opargToExpr(val))));
  }


  TclList tclListOfVariables(List<Variable> inputs)
  {
    TclList result = new TclList();
    for (Variable v : inputs)
      result.add(varToExpr(v));
    return result;
  }

  String stringOfVariables(List<Variable> inputs, List<Variable> outputs)
  {
    StringBuilder sb =
      new StringBuilder(inputs.size()+outputs.size()*32);

    Iterator<Variable> it1 = inputs.iterator();
    Iterator<Variable> it2 = outputs.iterator();
    while (it1.hasNext())
    {
      Variable v = it1.next();
      Value val = varToExpr(v);
      val.appendTo(sb);
      if (it1.hasNext() || it2.hasNext())
        sb.append(' ');
    }
    while (it2.hasNext())
    {
      Variable v = it2.next();
      Value val = varToExpr(v);
      val.appendTo(sb);
      if (it2.hasNext())
        sb.append(' ');
    }

    return sb.toString();
  }

  /** This prevents duplicate "package require" statements */
  private final Set<String> requiredPackages = new HashSet<String>();

  @Override
  public void defineBuiltinFunction(String name, String pkg,
                      String version, String symbol,
                      FunctionType type)
  {
    String pv = pkg+version;
    if (!pkg.equals("turbine")) {
      if (!requiredPackages.contains(pv))
      {
        PackageRequire pr = new PackageRequire(pkg, version);
        pointStack.peek().add(pr);
        requiredPackages.add(pv);
        pointStack.peek().add(new Command(""));
      }
    }
    builtinSymbols.put(name, new TCLFunRef(pkg, symbol));
    logger.debug("TurbineGenerator: Defined built-in " + name);
  }

  @Override
  public void startCompositeFunction(String functionName,
                                     List<Variable> oList,
                                     List<Variable> iList,
                                     boolean async)
  throws UserException
  {
    List<String> outputs = prefixVars(Variable.nameList(oList));
    List<String> inputs  = prefixVars(Variable.nameList(iList));
    // System.out.println("function" + functionName);
    boolean isMain = functionName.equals("main");
    if (isMain)
      functionName = MAIN_FUNCTION_NAME;
    else
      functionName = COMP_FN_PREFIX + functionName;
    List<String> args =
      new ArrayList<String>(inputs.size()+outputs.size());
    if (!isMain) {
      args.add(Turbine.LOCAL_STACK_NAME);
    }
    args.addAll(outputs);
    args.addAll(inputs);

    // This better be the bottom
    Sequence point = pointStack.peek();

    //TODO: call const init code
    Sequence s = new Sequence();
    Proc proc = new Proc(functionName, usedTclFunctionNames, args, s);

    point.add(proc);
    s.add(Turbine.turbineLog("function:"+functionName));

    if (noStack() && isMain) {
      s.add(Turbine.createDummyStackFrame());
    }

    if (!noStack()) {
      TclTree[] setupStack;
      if (isMain) {
        setupStack = Turbine.createStackFrame(StackFrameType.MAIN);
      } else {
        setupStack = Turbine.createStackFrame(StackFrameType.COMPOSITE);
      }
      s.add(setupStack);
      if (!noStackVars()) {
        for (Variable v : iList)
        {
          Command command = Turbine.storeInStack(v.getName(),
                                      prefixVar(v.getName()));
          s.add(command);
        }
        for (Variable v : oList)
        {
          Command command = Turbine.storeInStack(v.getName(),
                                            prefixVar(v.getName()));
          s.add(command);
        }
      }
    }

    pointStack.push(s);
  }

    @Override
    public void endCompositeFunction()
  {
    pointStack.pop();
  }

    @Override
    public void startNestedBlock()
  {
    Sequence block = new Sequence();
    if (!noStack()) {
      TclTree[] t = Turbine.createStackFrame(StackFrameType.NESTED);
      block.add(t);
    }
    Sequence point = pointStack.peek();
    point.add(block);
    pointStack.push(block);
  }

    @Override
    public void endNestedBlock() {
    pointStack.pop();
  }

    @Override
    public void addComment(String comment) {
      pointStack.peek().add(new Comment(comment));
    }

  /** NOT UPDATED */

    @Override
    public void defineApp(String functionName,
                          List<Variable> iList,
                          List<Variable> oList, String body)
  {
      // String inputs  = Declaration.names(iList);
    // String outputs = Declaration.names(oList);

    throw new ParserRuntimeException("defineApp not implemented yet");
    /*
    StringBuilder sb = new StringBuilder(1024);
    sb.append("proc ");
    sb.append(functionName);
    sb.append(" { ");
    sb.append(inputs);
    sb.append(" ");
    sb.append(outputs);
    sb.append(" } { \n\n");
    sb.append("\n");
    sb.append(body);
    sb.append("}\n");*/

  }

  /**
   * @param condition the variable name to branch based on
   * @param hasElse whether there will be an else clause ie. whether startElseBlock()
   *                will be called later for this if statement
   */
    @Override
    public void startIfStatement(Variable condition, boolean hasElse)
  {
    logger.trace("startIfStatement()...");
    assert(condition != null);
    assert(condition.getStorage() == VariableStorage.LOCAL);
    assert(condition.getType().equals(Types.VALUE_INTEGER) ||
        condition.getType().equals(Types.VALUE_BOOLEAN));


    Sequence thenBlock = new Sequence();
    Sequence elseBlock = hasElse ? new Sequence() : null;
    if (!noStack()) {
      thenBlock.add(Turbine.createStackFrame(StackFrameType.NESTED));
      if (hasElse) {
        elseBlock.add(Turbine.createStackFrame(StackFrameType.NESTED));
      }
    }

    If i = new If(varToExpr(condition),
        thenBlock, elseBlock);
    pointStack.peek().add(i);

    if (hasElse) {
       // Put it on the stack so it can be retrieved when we start else block
      pointStack.push(elseBlock);
    }
    pointStack.push(thenBlock);
  }

  @Override
    public void startElseBlock() {
      logger.trace("startElseBlock()...");
    pointStack.pop(); // Remove then block
  }

    @Override
    public void endIfStatement()
  {
    logger.trace("endIfStatement()...");
    pointStack.pop();
  }

    @Override
    public void startWaitStatement(String procName, List<Variable> waitVars,
        List<Variable> usedVariables, List<Variable> containersToRegister,
        boolean explicit) {
      logger.trace("startWaitStatement()...");
      startAsync(procName, waitVars, usedVariables, containersToRegister,
                                                    false);
    }

    @Override
    public void endWaitStatement(List<Variable> containersToRegister) {
      logger.trace("endWaitStatement()...");
      endAsync(containersToRegister);
    }

    /**
     * Internal helper to implement constructs that need to wait for
     * a number of variables, and then run some code
     * @param procName
     * @param waitVars
     * @param usedVariables
     * @param containersToRegister
     * @param shareWork if true, work will be shared with other rule engines
     *                  at the cost of higher overhead
     */
    private void startAsync(String procName, List<Variable> waitVars,
        List<Variable> usedVariables, List<Variable> containersToRegister,
        boolean shareWork) {
      List<String> args = new ArrayList<String>();
      args.add(Turbine.LOCAL_STACK_NAME);
      for (Variable v: usedVariables) {
        args.add(prefixVar(v.getName()));
      }

      Sequence constructProc = new Sequence();

      String uniqueName = uniqueTCLFunctionName(procName);
      Proc proc = new Proc(uniqueName, usedTclFunctionNames, args,
                                                    constructProc);
      tree.add(proc);

      // Build up the rule string
      List<Value> inputs = new ArrayList<Value>();
      for (Variable w: waitVars) {
        inputs.add(varToExpr(w));
      }

      for (Variable c: containersToRegister) {
        pointStack.peek().add(
              Turbine.containerSlotCreate(varToExpr(c)));
      }
      
      TclList action = buildAction(uniqueName, usedVariables);
      pointStack.peek().add(
            Turbine.rule(uniqueName, inputs, action, shareWork));

      pointStack.push(constructProc);
    }

    private void endAsync(List<Variable> containersToRegister) {
      for (Variable v: containersToRegister) {
        pointStack.peek().add(Turbine.containerSlotDrop(varToExpr(v)));
      }
      pointStack.pop();
    }


    private TclList buildAction(String procName,
        List<Variable> usedVariables) {

      ArrayList<Expression> ruleTokens = new ArrayList<Expression>();
      ruleTokens.add(new Token(procName));
      ruleTokens.add(new Value(Turbine.LOCAL_STACK_NAME));
      // Pass in variable ids directly in rule string
      for (Variable v: usedVariables) {
        SwiftType t = v.getType();
        if (Types.isScalarFuture(t) || Types.isReference(t) ||
            Types.isArray(t) || Types.isStruct(t)) {
          // Just passing turbine id
          ruleTokens.add(varToExpr(v));
        } else if (Types.isScalarValue(t)) {
          PrimType pt = t.getPrimitiveType();
          if (pt == PrimType.INTEGER || pt == PrimType.BOOLEAN 
              || pt == PrimType.FLOAT || pt == PrimType.STRING) {
            // Serialize
            ruleTokens.add(varToExpr(v));
          } else {
            throw new ParserRuntimeException("Don't know how to pass" +
            		" var with type " + v);
          }
        } else {
          throw new ParserRuntimeException("Don't know how to pass var with type "
              + v);
        }
      }
      return new TclList(ruleTokens);
    }

    @Override
    public void startSwitch(Variable switchVar, List<Integer> caseLabels,
              boolean hasDefault) {
    logger.trace("startSwitch()...");
    assert(switchVar != null);
    assert(switchVar.getStorage() == VariableStorage.LOCAL);
    assert(switchVar.getType().equals(Types.VALUE_INTEGER));

    int casecount = caseLabels.size();
    if (hasDefault) casecount++;

    List<Sequence> caseBodies = new ArrayList<Sequence>(casecount);
    for (int c=0; c < casecount; c++) {
      Sequence casebody = new Sequence();
      // there might be new locals in the case
      if (!noStack()) {
        casebody.add(Turbine.createStackFrame(StackFrameType.NESTED));
      }
      caseBodies.add(casebody);
    }

    Switch sw = new Switch(varToExpr(switchVar),
        caseLabels, hasDefault, caseBodies);
    pointStack.peek().add(sw);

    for (int c = 1; c <= casecount; c++) {
      // Push case in reverse order so we can pop off as we add cases
      pointStack.push(caseBodies.get(casecount - c));
    }
  }

    @Override
    public void endCase() {
    logger.trace("endCase()...");
    // Pop the body of the last case statement off the stack
    pointStack.pop();

  }

  @Override
  public void endSwitch() {
    logger.trace("endSwitch()...");
    // don't pop anything off, last case should already be gone
  }

  @Override
  public void startForeachLoop(Variable arrayVar, Variable memberVar,
                    Variable loopCountVar, boolean isSync, boolean arrayClosed,
          List<Variable> usedVariables, List<Variable> containersToRegister) {
    assert(Types.isArray(arrayVar.getType()));
    assert(loopCountVar.getType().equals(Types.VALUE_INTEGER));

    int foreach_num = foreach_counter++;
    String procName = "foreach:" + foreach_num;

    ArrayList<Variable> passIn = new ArrayList<Variable>(usedVariables);
    if (!passIn.contains(arrayVar)) {
      passIn.add(arrayVar);
    }
    if (!arrayClosed) {
        startAsync(procName, Arrays.asList(arrayVar), passIn,
                  containersToRegister, false);
    }
    Sequence curr = pointStack.peek();

    String keysVar ="tcltmp:keys";
    Value tclArrayVar = varToExpr(arrayVar);
    SetVariable getKeys = new SetVariable(keysVar,
            new Square(Turbine.CONTAINER_LIST, tclArrayVar));
    curr.add(getKeys);
    Sequence loopBody = new Sequence();
    Square keyList = new Square(
        Turbine.CONTAINER_LIST,
        varToExpr(arrayVar));

    ForEach tclLoop = new ForEach(new Token(prefixVar(loopCountVar.getName())),
       keyList, loopBody);
    curr.add(tclLoop);
    pointStack.push(loopBody);


    String tclMemberVar = prefixVar(memberVar.getName());
    // Load the array member
    loopBody.add(new SetVariable(tclMemberVar,
                 new Square(Turbine.CONTAINER_GET, tclArrayVar,
                     varToExpr(loopCountVar))));

    if (!isSync) {
      // pass in the array member and loop count var along with other used vars
      ArrayList<Variable> loopUsedVars = new ArrayList<Variable>(usedVariables);
      loopUsedVars.add(memberVar);
      loopUsedVars.add(loopCountVar);
      startAsync("foreach:" + foreach_num + ":body",
          new ArrayList<Variable>(), loopUsedVars, containersToRegister,
          true);
    }
  }


  private Value varToExpr(Variable v) {
    return new Value(prefixVar(v.getName()));
  }

  private Expression opargToExpr(Oparg in) {
    switch (in.getType()) {
    case INTVAL:
      return new LiteralInt(in.getIntLit());
    case BOOLVAL:
      return new LiteralInt(in.getBoolLit() ? 1 : 0);
    case STRINGVAL:
      return new TclString(in.getStringLit(), true);
    case VAR:
      return new Value(prefixVar(in.getVariable().getName()));
    case FLOATVAL:
      return new LiteralFloat(in.getFloatLit());
    default:
      throw new ParserRuntimeException("Unknown oparg type: "
          + in.getType().toString());
    }
  }

  @Override
  public void startRangeLoop(String loopName, Variable loopVar, Oparg start,
      Oparg end, Oparg increment, boolean isSync, List<Variable> usedVariables,
      List<Variable> containersToRegister, int desiredUnroll, int splitDegree) {
    assert(start.getType() == OpargType.INTVAL ||
        (start.getType() == OpargType.VAR &&
            start.getVariable().getType().equals(Types.VALUE_INTEGER)));
    assert(end.getType() == OpargType.INTVAL ||
        (end.getType() == OpargType.VAR &&
            end.getVariable().getType().equals(Types.VALUE_INTEGER)));
    assert(increment.getType() == OpargType.INTVAL ||
        (increment.getType() == OpargType.VAR &&
                    increment.getVariable().getType().equals(Types.VALUE_INTEGER)));
    assert(loopVar.getType().equals(Types.VALUE_INTEGER));
    Expression startE = opargToExpr(start);
    Expression endE = opargToExpr(end);
    Expression incrE = opargToExpr(increment);
    
    if (splitDegree > 0) {
      startRangeLoopWithSplitting(loopName, loopVar, isSync, usedVariables,
              containersToRegister, splitDegree, startE, endE, incrE);
    } else {
      startRangeLoop2(loopName, loopVar, isSync, usedVariables,
              containersToRegister, startE, endE, incrE);
    }
  }

  private void startRangeLoopWithSplitting(String loopName, Variable loopVar,
          boolean isSync, List<Variable> usedVariables,
          List<Variable> containersToRegister, int splitDegree,
          Expression startE, Expression endE, Expression incrE) {
    // Create two procedures that will be called: an outer procedure
    //  that recursively breaks up the foreach loop into chunks, 
    //  and an inner procedure that actually runs the loop
    ArrayList<String> args = new ArrayList<String>();
    args.add(Turbine.LOCAL_STACK_NAME);
    for (Variable uv: usedVariables) {
      args.add(prefixVar(uv.getName()));
    }
    args.add(TCLTMP_RANGE_LO);
    args.add(TCLTMP_RANGE_HI);
    args.add(TCLTMP_RANGE_INC);

    Value loVal = new Value(TCLTMP_RANGE_LO);
    Value hiVal = new Value(TCLTMP_RANGE_HI);
    Value incVal = new Value(TCLTMP_RANGE_INC);
    
    List<Expression> commonArgs = new ArrayList<Expression>();
    commonArgs.add(new Value(Turbine.LOCAL_STACK_NAME));
    for (Variable uv: usedVariables) {
      commonArgs.add(varToExpr(uv));
    }
    
    List<Expression> outerCallArgs = new ArrayList<Expression>(commonArgs);
    outerCallArgs.add(startE);
    outerCallArgs.add(endE);
    outerCallArgs.add(incrE);
    
    List<Expression> innerCallArgs = new ArrayList<Expression>(commonArgs);
    innerCallArgs.add(loVal);
    innerCallArgs.add(hiVal);
    innerCallArgs.add(incVal);
    
    Sequence outer = new Sequence();
    String outerProcName = loopName + ":outer";
    tree.add(new Proc(outerProcName, 
            usedTclFunctionNames, args, outer));
    
    Sequence inner = new Sequence();
    String innerProcName = loopName + ":inner";
    tree.add(new Proc(innerProcName, 
          usedTclFunctionNames, args, inner));
    
    // Call outer directly
    pointStack.peek().add(new Command(outerProcName, 
            outerCallArgs));
                     
    
    String itersLeft = "tcltmp:itersleft";
    // itersLeft = ceil( (hi - lo + 1) /(double) inc)) 
    // ==> itersLeft = ( (hi - lo) / inc ) + 1 
    outer.add(new SetVariable(itersLeft, Square.arithExpr( new Token(
            String.format("((${%s} - ${%s}) / ${%s}) + 1",
                   TCLTMP_RANGE_HI, TCLTMP_RANGE_LO, TCLTMP_RANGE_INC)))));
    Expression doneSplitting = Square.arithExpr(
            new Value(itersLeft), new Token("<="), 
            new LiteralInt(splitDegree));
    Sequence thenB = new Sequence();
    Sequence elseB = new Sequence();
    
    // if (iters < splitFactor) then <call inner> else <split more>
    If splitIf = new If(doneSplitting, thenB, elseB);
    outer.add(splitIf);
    
    thenB.add(new Command(innerProcName, innerCallArgs));
    
    Sequence splitBody = new Sequence();
    String splitStart = "tcltmp:splitstart";
    String skip = "tcltmp:skip";
    // skip = max(splitFactor,  ceil(iters /(float) splitfactor))
    // skip = max(splitFactor,  ((iters - 1) /(int) splitfactor) + 1)
    elseB.add(new SetVariable(skip, Square.arithExpr(new Token(
          String.format("max(%d, ((${%s} - 1) / %d ) + 1)", 
                  splitDegree, itersLeft, splitDegree)))));
    
    ForLoop splitLoop = new ForLoop(splitStart, loVal, 
            hiVal, new Value(skip), splitBody);
    elseB.add(splitLoop);
    
    
    ArrayList<Expression> outerRecCall = new 
                     ArrayList<Expression>();
    outerRecCall.add(new Token(outerProcName));
    outerRecCall.addAll(commonArgs);
    outerRecCall.add(new Value(splitStart));
    // splitEnd = min(hi, start + skip - 1)
    Square splitEnd = Square.arithExpr(new Token(String.format(
            "min(${%s}, ${%s} + ${%s} - 1)", TCLTMP_RANGE_HI, 
            splitStart, skip)));
    outerRecCall.add(splitEnd);
    outerRecCall.add(incVal);
    
    splitBody.add(Turbine.rule(outerProcName, new ArrayList<Value>(0),
                    new TclList(outerRecCall), true));
    
    pointStack.push(inner);
    startRangeLoop2(loopName, loopVar, isSync, usedVariables,
            containersToRegister, loVal, hiVal, incVal);
  }

  private void startRangeLoop2(String loopName, Variable loopVar,
          boolean isSync, List<Variable> usedVariables,
          List<Variable> containersToRegister, Expression startE,
          Expression endE, Expression incrE) {
    Sequence loopBody = new Sequence();
    String loopVarName = prefixVar(loopVar.getName());
    ForLoop tclLoop = new ForLoop(loopVarName, startE, endE, incrE, loopBody);
    pointStack.peek().add(tclLoop);
    pointStack.push(loopBody);


    ArrayList<Variable> loopUsedVars = new ArrayList<Variable>(usedVariables);
    loopUsedVars.add(loopVar);
    if (!isSync) {
      startAsync(loopName + ":body",
          new ArrayList<Variable>(), loopUsedVars, containersToRegister,
          true);
    }
  }

  @Override
  public void endRangeLoop(boolean isSync,
                        List<Variable> containersToRegister,
                        int splitDegree) {
    assert(pointStack.size() >= 2);
    if (!isSync) {
      assert(pointStack.size() >= 3);
      endAsync(containersToRegister); // Swift loop body
    }
    if (splitDegree > 0) {
      pointStack.pop(); // inner proc body
    }
    pointStack.pop(); // for loop body
  }


  @Override
  public void endForeachLoop(boolean isSync, boolean arrayClosed,
                              List<Variable> containersToRegister) {
    assert(pointStack.size() >= 2);
    if (!isSync) {
      assert(pointStack.size() >= 3);
      endAsync(containersToRegister); // Swift loop body
    }
    pointStack.pop(); // tclloop body
    if (!arrayClosed) {
      endAsync(containersToRegister); // outer wait for container
    }
  }


  @Override
  public void addGlobal(String name, Oparg val) {
    String tclName = prefixVar(name);
    globInit.add(Turbine.makeTCLGlobal(tclName));
    String typePrefix;
    Expression expr;
    Command setCmd;
    switch (val.getType()) {
    case INTVAL:
      typePrefix = Turbine.INTEGER_TPREFIX;
      expr = new LiteralInt(val.getIntLit());
      setCmd = Turbine.integerSet(tclName, expr);
      break;
    case FLOATVAL:
      typePrefix = Turbine.FLOAT_TPREFIX;
      expr = new LiteralFloat(val.getFloatLit());
      setCmd = Turbine.floatSet(tclName, expr);
      break;
    case STRINGVAL:
      typePrefix = Turbine.STRING_TPREFIX;
      expr = new TclString(val.getStringLit(), true);
      setCmd = Turbine.stringSet(tclName, expr);
      break;
    case BOOLVAL:
      typePrefix = Turbine.INTEGER_TPREFIX;
      expr = new LiteralInt(val.getBoolLit() ? 1 : 0);
      setCmd = Turbine.integerSet(tclName, expr);
      break;
    default:
      throw new ParserRuntimeException("Non-constant oparg type "
          + val.getType());
    }
    globInit.add(Turbine.allocate(tclName, typePrefix));
    globInit.add(setCmd);
  }

  /**
     Generate and return Tcl from our internal TclTree
   */
    @Override
    public String code()
  {
    StringBuilder sb = new StringBuilder(10*1024);
    try
    {
      tree.appendTo(sb);
    }
    catch (Exception e)
    {
      System.out.println("CODE GENERATOR INTERNAL ERROR");
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.out.println("code generated before error:");
      System.out.println(sb);
      System.out.println("exiting");
      System.exit(ExitCode.ERROR_INTERNAL.code());
    }
    return sb.toString();
  }


    private static String prefixVar(String varname) {
      // Replace the internal names of temporary variables with
      // shorter ones for generated tcl code
      if (varname.startsWith(Variable.LOCAL_TMP_VAR_PREFIX)) {
        return TCL_LOCAL_TMP_VAR_PREFIX + varname.substring(Variable.LOCAL_TMP_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.TMP_VAR_PREFIX)) {
        return TCL_TMP_VAR_PREFIX + varname.substring(
                Variable.TMP_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.ALIAS_VAR_PREFIX)) {
        return TCL_ALIAS_VAR_PREFIX + varname.substring(Variable.ALIAS_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.STRUCT_FIELD_VAR_PREFIX)) {
        return TCL_STRUCT_FIELD_VAR_PREFIX + varname.substring(
            Variable.STRUCT_FIELD_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.LOCAL_VALUE_VAR_PREFIX))  {
        return TCL_VALUE_VAR_PREFIX +
            varname.substring(Variable.LOCAL_VALUE_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.OPT_VALUE_VAR_PREFIX))  {
        return TCL_OPT_VALUE_VAR_PREFIX +
            varname.substring(Variable.OPT_VALUE_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.LOOP_INDEX_VAR_PREFIX)) {
        return TCL_LOOPINDEX_VAR_PREFIX +
            varname.substring(Variable.LOOP_INDEX_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.GLOBAL_CONST_VAR_PREFIX)) {
        return TCL_GLOBAL_CONST_VAR_PREFIX +
            varname.substring(Variable.GLOBAL_CONST_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.DEREF_COMPILER_VAR_PREFIX)) {
        return TCL_DEREF_COMPILER_VAR_PREFIX +
            varname.substring(Variable.DEREF_COMPILER_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.LOOP_INDEX_VAR_PREFIX)) {
        return TCL_LOOP_INDEX_VAR_PREFIX +
            varname.substring(Variable.LOOP_INDEX_VAR_PREFIX.length());
      } else if (varname.startsWith(Variable.OUTER_VAR_PREFIX)) {
        return TCL_OUTER_VAR_PREFIX +
            varname.substring(Variable.OUTER_VAR_PREFIX.length());

      } else {
        return TCL_USER_VAR_PREFIX + varname;
      }
    }

    private static List<String> prefixVars(List<String> vlist) {
      ArrayList<String> result = new ArrayList<String>(vlist.size());
      for (String v: vlist) {
        result.add(prefixVar(v));
      }
      return result;
    }


    private boolean noStackVars() {
      boolean no_stack_vars;
      try {
        no_stack_vars = Settings.getBoolean(Settings.TURBINE_NO_STACK_VARS);
      } catch (InvalidOptionException e) {
        e.printStackTrace();
        throw new ParserRuntimeException(e.getMessage());
      }
      return no_stack_vars;
    }

    private boolean noStack() {
      boolean no_stack;
      try {
        no_stack = Settings.getBoolean(Settings.TURBINE_NO_STACK);
      } catch (InvalidOptionException e) {
        e.printStackTrace();
        throw new ParserRuntimeException(e.getMessage());
      }
      return no_stack;
    }

    @Override
    public void optimise() {
      // do nothing
    }

    @Override
    public void regenerate(CompilerBackend codeGen) {
      throw new UnsupportedOperationException("TurbineGenerator can't "
          + " reconstitute code");

    }

    @Override
    public void startLoop(String loopName, List<Variable> loopVars,
        List<Variable> initVals, List<Variable> usedVariables,
        List<Variable> containersToRegister, List<Boolean> blockingVars) {

      // call rule to start the loop, pass in initVals, usedVariables
      ArrayList<String> loopFnArgs = new ArrayList<String>();
      ArrayList<Value> firstIterArgs = new ArrayList<Value>();
      loopFnArgs.add(Turbine.LOCAL_STACK_NAME);
      firstIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));

      for (Variable arg: loopVars) {
        loopFnArgs.add(prefixVar(arg.getName()));
      }
      for (Variable init: initVals) {
        firstIterArgs.add(varToExpr(init));
      }

      for (Variable uv: usedVariables) {
        loopFnArgs.add(prefixVar(uv.getName()));
        firstIterArgs.add(varToExpr(uv));
      }


      // See which values the loop should block on
      ArrayList<Value> blockingVals = new ArrayList<Value>();
      assert(blockingVars.size() == initVals.size());
      for (int i = 0; i < blockingVars.size(); i++) {
        Variable iv = initVals.get(i);
        if (blockingVars.get(i)) {
          blockingVals.add(varToExpr(iv));
        }
      }


      // Keep containers open
      for (Variable v: containersToRegister) {
        pointStack.peek().add(Turbine.containerSlotCreate(varToExpr(v)));
      }

      String uniqueLoopName = uniqueTCLFunctionName(loopName);

      pointStack.peek().add(Turbine.loopRule(
          uniqueLoopName, firstIterArgs, blockingVals));

      Sequence loopBody = new Sequence();
      Proc loopProc = new Proc(uniqueLoopName, usedTclFunctionNames,
                                              loopFnArgs, loopBody);
      tree.add(loopProc);
      // add loop body to pointstack, loop to loop stack
      pointStack.push(loopBody);
      loopNameStack.push(uniqueLoopName);
    }

    private String uniqueTCLFunctionName(String tclFunctionName) {
      String unique = tclFunctionName;
      int next = 1;
      while (usedTclFunctionNames.contains(unique)) {
        unique = tclFunctionName + "-" + next;
        next++;
      }
      return unique;
    }

    @Override
    public void loopContinue(List<Variable> newVals,
           List<Variable> usedVariables, List<Variable> registeredContainers,
           List<Boolean> blockingVars) {
      ArrayList<Value> nextIterArgs = new ArrayList<Value>();
      String loopName = loopNameStack.peek();
      nextIterArgs.add(new Value(Turbine.LOCAL_STACK_NAME));

      for (Variable v: newVals) {
        nextIterArgs.add(varToExpr(v));
      }
      for (Variable v: usedVariables) {
        nextIterArgs.add(varToExpr(v));
      }
      ArrayList<Value> blockingVals = new ArrayList<Value>();
      assert(newVals.size() == blockingVars.size());
      for (int i = 0; i < newVals.size(); i++) {
        if (blockingVars.get(i)) {
          blockingVals.add(varToExpr(newVals.get(i)));
        }
      }
      pointStack.peek().add(Turbine.loopRule(loopName,
          nextIterArgs, blockingVals));
    }

    @Override
    public void loopBreak(List<Variable> containersToClose) {
      for (Variable arr: containersToClose) {
        pointStack.peek().add(
             Turbine.containerSlotDrop(varToExpr(arr)));
      }
    }

    @Override
    public void endLoop() {
      assert(pointStack.size() >= 2);
      assert(loopNameStack.size() > 0);
      pointStack.pop();
      loopNameStack.pop();
    }

    /**
     * Reloads variables that are accessible in the stack into the local
     * TCL procedure
     * @param tclVarPrefix a prefix to add to the names of all TCL variables
     * @param variable   the name of the variable to reload from stack container
     * @param scopeLevel how many scopes outside the current do we need to
     *                   look to find the variable
     * @return the Tcl expression to load the variable
     */
    /*
    private static TclTree[] loadFromStack(
                            Collection<VisibleVariable> vars)
    {
      if (DISABLE_STACK_VAR_STORAGE) { return new TclTree[0]; }
      ArrayList<VisibleVariable> sortedVars = new ArrayList<VisibleVariable>(vars.size());
      sortedVars.addAll(vars);

      // Sort the variables in descending order of scope
      Collections.sort(sortedVars, new VisibleVariable.ScopeComparator());

      ArrayList<TclTree> result = new ArrayList<TclTree>();

      int currentScope = 0;
      String currentScopeContainer = Turbine.LOCAL_STACK_NAME;

      for (VisibleVariable vv: sortedVars) {
        // Load the needed container for the parent scope
        while (vv.getScopeLevel() > currentScope) {
          String oldScope = currentScopeContainer;
          currentScope++;
          currentScopeContainer = "__pscope" + currentScope;

          //TODO: lookup _parent in oldScope and assign to currentScopeContainer

          SetVariable sv = Turbine.lookupParentStack(
                  currentScopeContainer, oldScope);
          result.add(sv);
        }

        // lookup variable in currentScopeContainer

        SetVariable sv = stackVarLookup(currentScopeContainer, vv);
        result.add(sv);

      }


      return result.toArray(new TclTree[result.size()]);
    }
     */
    /*
    private static SetVariable stackVarLookup(String stackName,
        VisibleVariable vv) {
      String tclVarName = prefixVar(vv.getVariable().getName());
      String varName = vv.getVariable().getName();

      SetVariable sv = Turbine.stackLookup(stackName,
                                                    tclVarName, varName);
      return sv;
    }
*/
}
