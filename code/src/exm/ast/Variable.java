
package exm.ast;

import java.util.*;

import exm.ast.Context;
import exm.ast.SwiftAST;
import exm.ast.Types.SwiftType;
import exm.parser.antlr.ExMParser;
import exm.parser.util.InvalidSyntaxException;
import exm.parser.util.ParserRuntimeException;
import exm.parser.util.ParserUtils;
import exm.parser.util.UndefinedTypeException;

public class Variable
{
  private final SwiftType type;
  private final String name;
  private final VariableStorage storage;
  private final DefType defType;
  private final String mapping;

  public static final String TMP_VAR_PREFIX = "__t";
  public static final String LOCAL_TMP_VAR_PREFIX = "__l";
  public static final String ALIAS_VAR_PREFIX = "__alias";
  public static final String STRUCT_FIELD_VAR_PREFIX = "__sf_";
  public static final String LOCAL_VALUE_VAR_PREFIX = "__v_";
  /* Separate value prefix to avoid name clashes for optimizer 
   *    inserted variables */
  public static final String OPT_VALUE_VAR_PREFIX = "__ov_";
  public static final String LOOP_INDEX_VAR_PREFIX = "__i";
  public static final String GLOBAL_CONST_VAR_PREFIX = "__c";
  public static final String DEREF_COMPILER_VAR_PREFIX = "__dr_";
  public static final String LOOP_COND_PREFIX = "__xcond";
  public static final String OUTER_VAR_PREFIX = "__outer";

  public enum VariableStorage
  {
    /** Reference stored in global stack frame */
    STACK,
    /** Reference stored only temporarily in control flow */
    TEMPORARY,
    /** Reference to variable allocated elsewhere */
    ALIAS,
    /** Value only stored in interpreter */
    LOCAL,
    /** Global constant */
    GLOBAL_CONST,
  }

  /**
   * How the variable was defined (e.g. local vs argument)
   */
  public enum DefType
  {
    /** Local variable */
    LOCAL_USER,
    /** Compiler-generated local */
    LOCAL_COMPILER,
    /** Input argument */
    INARG,
    /** Output argument */
    OUTARG,
    /** Global constant generated by compiler */
    GLOBAL_CONST,
  }

  public Variable(SwiftType type)
  {
    this.type = type;
    this.name = "...";
    this.storage = VariableStorage.ALIAS;
    this.defType = DefType.INARG;
    this.mapping = null;
  }

  public Variable(SwiftType type, String name,
                  VariableStorage storage, DefType defType)
  {
    this.type = type;
    this.name = name;
    this.storage = storage;
    this.defType = defType;
    this.mapping = null;
  }
  
  public Variable(SwiftType type, String name,
      VariableStorage storage, DefType defType, String mapping)
  {
    this.type = type;
    this.name = name;
    this.storage = storage;
    this.defType = defType;
    this.mapping = mapping;
  }

  public String getName()
  {
    return name;
  }

  public SwiftType getType()
  {
    return type;
  }

  public VariableStorage getStorage()
  {
    return storage;
  }

 public DefType getDefType() {
    return defType;
  }

  public String getMapping() {
    return mapping;
  }

  public boolean isMapped() {
    return mapping != null;
  }

  
/**
  * Take a DECLARE_MULTI or DECLARE_SINGLE subtree of the AST and return the appropriate declared
  * variable.  Doesn't check to see if variable already defined
  * @param errorContext the current context, for info to add to error message
  * @param baseType the type preceding the declaration 
  * @param tree a parse tree with the root a DECLARE_MULTI or DECLARE_SINGLE 
  *                                                               subtree
  * @return
  * @throws UndefinedTypeException
 * @throws InvalidSyntaxException 
  */
  public static Variable fromDeclareVariableTree(
      Context context, SwiftType baseType, SwiftAST tree, DefType deftype)
  throws UndefinedTypeException, InvalidSyntaxException
  {
    assert(tree.getType() == ExMParser.DECLARE_VARIABLE_REST);
    String mappedTo = null;
    assert(tree.getChildCount() >= 1);
    SwiftAST nameTree = tree.child(0);
    assert(nameTree.getType() == ExMParser.ID);
    String varName = nameTree.getText();
    
    SwiftType varType = baseType;
    for (int i = 1; i < tree.getChildCount(); i++) {
      SwiftAST subtree = tree.child(i);
      if (subtree.getType() == ExMParser.ARRAY) {
        varType = new Types.ArrayType(varType);
      } else if (subtree.getType() == ExMParser.MAPPING) {
        assert(mappedTo == null); // should be first mapping
        assert(subtree.getChildCount() == 1);
        mappedTo = ParserUtils.unescapeString(context, 
                          ParserUtils.unquote(subtree.child(0).getText()));
      } else {
        throw new ParserRuntimeException("Unexpected token in variable " +
        		"declaration: " + ExMParser.tokenNames[subtree.getType()]);
      }
    }
    return new Variable(varType, varName, VariableStorage.STACK, deftype, 
                                                              mappedTo);
  }

  public static String names(List<Variable> list)
  {
    StringBuilder sb = new StringBuilder(list.size()*16);
    Iterator<Variable> it = list.iterator();
    while (it.hasNext())
    {
      Variable v = it.next();
      sb.append(v.getName());
      if (it.hasNext())
        sb.append(' ');
    }
    return sb.toString();
  }

  public static List<String> nameList(Collection<Variable> variables)
  {
    List<String> result = new ArrayList<String>(variables.size());
    nameFill(result, variables);
    return result;
  }
  
  public static Set<String> nameSet(Collection<Variable> variables)
  {
    Set<String> result = new HashSet<String>(variables.size());
    nameFill(result, variables);
    return result;
  }
  
  private static void nameFill(Collection<String> names,
                                  Collection<Variable> variables)
  {
    for (Variable v : variables)
      names.add(v.getName());
  }

  public static List<SwiftType> extractTypes(List<Variable> variables)
  {
    ArrayList<SwiftType> result = new ArrayList<SwiftType>(variables.size());
    for (Variable v: variables) {
      result.add(v.getType());
    }

    return result;
  }
  
  /**
   * Create dereferenced variable given a reference
   */
  public static Variable createDerefTmp(Variable ref, VariableStorage storage) {
    assert(Types.isReference(ref.getType()));
    Variable res = new Variable(ref.getType().getMemberType(),
        DEREF_COMPILER_VAR_PREFIX + ref.getName(),
        storage, DefType.LOCAL_COMPILER, 
        null);
    assert(Types.isReferenceTo(ref.getType(), res.getType()));
    return res;
  }

  @Override
  public String toString()
  {
    return type.toString()+':'+name;
  }

  /**
   * Find the first variable with a matching name in the provided collection
   * @param variables
   * @param name
   * @return
   */
  public static Variable findByName(Collection<Variable> variables,
      String name) {
    for (Variable v: variables) {
      if (v.getName().equals(name)) {
        return v;
      }
    }
    return null;
  }
}
