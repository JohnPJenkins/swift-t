#!/bin/zsh

# STC: Swift-Turbine Compiler

# Usage: stc <OPTIONS>* <INPUT> <OUTPUT>?
# Input: Given INPUT file
# Output: Given OUTPUT file or standard output
# Exit code: Result from java

# See help.txt or run "stc -h" for full options list

# Exit codes: (cf. ExitCode.java)
EXIT_ERROR_SCRIPT=6

COMPILER_OPTS=()

O1_OPTS=("constant-fold" "branch-predict" "dead-code-elim"
                    "flatten-nested" "shared-constants"
                    "forward-dataflow" "unroll-loops")
O2_OPTS=()
O3_OPTS=("wait-coalesce" "controlflow-fusion")

PARSER_HOME=$( cd $( dirname $0 )/.. ; /bin/pwd )

function get_compiler_opt_name() {
    case $1
        in
        constant-fold) echo "stc.opt.constant-fold"
                    return 0
                    ;;
        shared-constants) echo "stc.opt.shared-constants"
                    return 0
                    ;;
        branch-predict) echo "stc.opt.branch-predict"
                    return 0
                    ;;
        dead-code-elim) echo "stc.opt.dead-code-elim"
                    return 0
                    ;;
        flatten-nested) echo "stc.opt.flatten-nested"
                    return 0
                    ;;
        forward-dataflow) echo "stc.opt.forward-dataflow-analysis"
                    return 0
                    ;;
        wait-coalesce) echo "stc.opt.wait-coalesce"
                    return 0
                    ;;
        controlflow-fusion) echo "stc.opt.controlflow-fusion"
                    return 0
                    ;;
        disable-asserts) echo "stc.opt.disable-asserts"
                    return 0
                    ;;
        unroll-loops) echo "stc.opt.unroll-loops"
                    return 0
                    ;;

        array-switcheroo) echo "stc.array-ref-switcheroo"
                    return 0
                    ;;

        no-stack)   echo "stc.codegen.no-stack"
                    return 0
                    ;;
        no-stack-vars)
                    echo "stc.codegen.no-stack-vars"
                    return 0
                    ;;
       *)
         return 1
         ;;
    esac
}

function disable_opt() {
  local OPTNAME=$(get_compiler_opt_name $1)
  if [ -z "$OPTNAME" ]; then
    echo "ERROR Invalid compiler option $1" 1>&2
    return 1
  fi
  COMPILER_OPTS+="-D${OPTNAME}=false"
}

function enable_opt() {
  local OPTNAME=$(get_compiler_opt_name $1)
  if [ -z "$OPTNAME" ]; then
    echo "ERROR Invalid compiler option $1" 1>&2
    return 1
  fi
  COMPILER_OPTS+="-D${OPTNAME}=true"
}

help()
{
  echo  ${PARSER_HOME}/help.txt
  cat ${PARSER_HOME}/help.txt
  exit 0
}

# Set this to 1 to debug this script (-V)
VERBOSE=0
verbose()
{
  if (( VERBOSE ))
  then
    print "stc: ${*}"
  fi
}

TURBINE_INSTALL=@TURBINE_INSTALL@

set_turbine_home()
{
  if [[ -z ${TURBINE_HOME} ]]
  then
    TURBINE_HOME=${TURBINE_INSTALL}
  fi
}

report_version()
{
  print "STC: Swift-Turbine Compiler"
  printf "\t for Turbine: "
  cat ${PARSER_HOME}/turbine-version.txt
  set_turbine_home
  print "TURBINE_HOME=${TURBINE_HOME}"
  exit 0
}

# OUTPUT_MODE= turbine or cpp
OUTPUT_MODE=turbine

# UPDATE= If 1, only compile if target not up-to-date
UPDATE=0

# JUST_VERSION= If 1, just report the version
JUST_VERSION=0

while getopts "d:EhI:l:t:T:O:C:uvV" OPTION
do
  case ${OPTION}
    in
    d) DEBUG_PORT=${OPTARG}
      verbose "DEBUG_PORT: ${DEBUG_PORT}"
      ;;
    E) OUTPUT_MODE=cpp
      ;;
    h)
      verbose "HELP:"
      help
      ;;
    I) CPP_INCLUDE+="-I ${OPTARG} "
      ;;
    l) LOGFILE=${OPTARG}
      verbose "LOGFILE: ${LOGFILE}"
      ;;
    t) verbose "TURNOFF: ${OPTARG}"
      disable_opt ${OPTARG}
      ;;
    T) verbose "TURNON: ${OPTARG}"
      enable_opt ${OPTARG}
      ;;
    O) verbose "Optimization level ${OPTARG}"
      if [ ${OPTARG} = 0 ]; then
        for opt in $O1_OPTS $O2_OPTS $O3_OPTS; do
            disable_opt ${opt}
        done
      elif [ ${OPTARG} = 1 -o ${OPTARG} = 2 -o ${OPTARG} = 3 ]; then
        for opt in $O1_OPTS; do
            enable_opt ${opt}
        done
        if [ ${OPTARG} -ge 2 ]; then
            for opt in $O2_OPTS; do
                enable_opt ${opt}
            done
            if [ ${OPTARG} -ge 3 ]; then
                for opt in $O3_OPTS; do
                    enable_opt ${opt}
                done
            fi
        fi
      else
        echo "Invalid optimization level -O ${OPTARG}"
        return 1
      fi
      ;;
    C) verbose "IC Output: ${OPTARG}"
       COMPILER_OPTS+="-Dstc.ic.output-file=${OPTARG}"
       ;;
    u) UPDATE=1
      ;;
    v)
      report_version
      ;;
    V)
      (( VERBOSE )) && set -x
      VERBOSE=1
      ;;
    *)
      # getopts already printed an error message
      return ${EXIT_ERROR_SCRIPT}
      ;;
  esac
done

shift $(( OPTIND-1 ))

# After shifting out the options we are left with the file names
INPUT=$1
# This is optional (defaults to stdout)
OUTPUT=$2

if [[ ${INPUT} == "" ]]
then
  print "stc: no input file"
  return ${EXIT_ERROR_SCRIPT}
fi

if [[ ! -f ${INPUT} ]]
then
  print "stc: not readable: ${INPUT}"
  return ${EXIT_ERROR_SCRIPT}
fi

# Clear this in case the user has set it
unset DEBUG
if [[ ${DEBUG_PORT} != "" ]]
then
  export DEBUG=-agentlib:jdwp=transport=dt_socket,server=y,address=${DEBUG_PORT}
fi

STDOUT=/dev/stdout
if [[ ${OUTPUT} == "" ]]
then
  OUTPUT=${STDOUT}
fi

# Check timestamps (-u)
if [[ ${UPDATE} == 1 && ${OUTPUT} != ${STDOUT} ]]
then
  if [[ -f ${OUTPUT} ]]
  then
    if [[ ${OUTPUT} -nt ${INPUT} ]]
    then
      # Output is up-to-date: done
      verbose "output is up-to-date."
      return 0
    fi
  fi
fi

ANTLR=${PARSER_HOME}/lib/antlr-3.4-complete-no-antlrv2.jar
PARSER=${PARSER_HOME}/lib/parser.jar
LOG4J=${PARSER_HOME}/lib/log4j-1.2.16.jar
JSON=${PARSER_HOME}/lib/json.jar
CLASSPATH=${ANTLR}:${PARSER}:${LOG4J}:${JSON}

TURBINE_VERSION=$( < ${PARSER_HOME}/turbine-version.txt )

FLAGS=( -ea -Dstc.turbine.version=${TURBINE_VERSION} )
if [[ ${LOGFILE} != "" ]]
then
  FLAGS+="-Dparser.logfile=${LOGFILE}"
fi
if [[ ${JUST_VERSION} == 1 ]]
then
  FLAGS+="-Dparser.just_version=1"
fi

# Find Turbine (for include path)
set_turbine_home

if [[ -z ${TURBINE_HOME} ]]
then
  print "Not set: TURBINE_HOME"
  return ${EXIT_ERROR_SCRIPT}
fi

# Add last resort include paths
CPP_INCLUDE+="-I ${PWD} "
CPP_INCLUDE+="-I ${TURBINE_HOME}/export"

MAIN=exm.stc.ui.Main

# Group all JVM args together
ARGS="${DEBUG} ${FLAGS} ${COMPILER_OPTS} -cp ${CLASSPATH}"

# Assemble preprocessor command line
# We use gcc -E because cpp is broken on Mac GCC 4.2.1
#    Cf. http://stackoverflow.com/questions/4137923
CPP="gcc -E -x c ${CPP_INCLUDE}"

if [[ ${OUTPUT_MODE} == "cpp" ]]
then
  # Just preprocess
  ${=CPP} ${INPUT} > ${OUTPUT}
  return ${?}
fi

# We use ZSH to make a special file for the pre-processed script
java ${=ARGS} ${MAIN} <( ${=CPP} ${INPUT} ) ${OUTPUT}
EXITCODE=${?}

if (( EXITCODE ))
then
  # Compile did not succeed: remove output
  if [[ ${OUTPUT} != /dev* && -f ${OUTPUT} ]]
  then
    rm ${OUTPUT}
  fi
fi

# Return the exit code from the java process
return ${EXITCODE}
