#!/bin/zsh

# STC: Swift-Turbine Compiler

# Usage: stc <OPTIONS>* <INPUT> <OUTPUT>?
# Input: Given INPUT file
# Output: Given OUTPUT file or standard output
# Exit code: Result from java

# See help.txt or run "stc -h" for full options list

# Exit codes: (cf. ExitCode.java)
EXIT_ERROR_SCRIPT=6

STC_HOME=$( cd $( dirname $0 )/.. ; /bin/pwd )

STC_ENV=$STC_HOME/conf/stc-env.sh
if [ -f ${STC_ENV} ]
then 
  source ${STC_ENV}
else 
  echo "Warning: Configuration file ${STC_ENV} does not exist."
fi

COMPILER_OPTS=()

O1_OPTS=("constant-fold" "branch-predict" "dead-code-elim"
                    "flatten-nested" "shared-constants"
                    "forward-dataflow" "unroll-loops"
                     "controlflow-fusion" )
O2_OPTS=("wait-coalesce" "hoisting")
O3_OPTS=("pipeline")
EXPERIMENTAL_OPTS=()

# OUTPUT_MODE= turbine or cpp
OUTPUT_MODE=turbine

# UPDATE= If 1, only compile if target not up-to-date
UPDATE=0

typeset -T RPATH rpath
rpath=()

function get_compiler_opt_name() {
    case $1
        in
        constant-fold) echo "stc.opt.constant-fold"
                    return 0
                    ;;
        shared-constants) echo "stc.opt.shared-constants"
                    return 0
                    ;;
        branch-predict) echo "stc.opt.branch-predict"
                    return 0
                    ;;
        dead-code-elim) echo "stc.opt.dead-code-elim"
                    return 0
                    ;;
        flatten-nested) echo "stc.opt.flatten-nested"
                    return 0
                    ;;
        forward-dataflow) echo "stc.opt.forward-dataflow"
                    return 0
                    ;;
        wait-coalesce) echo "stc.opt.wait-coalesce"
                    return 0
                    ;;
        pipeline) echo "stc.opt.pipeline"
                    return 0
                    ;;
        controlflow-fusion) echo "stc.opt.controlflow-fusion"
                    return 0
                    ;; 
        function-inline) echo "stc.opt.function-inline"
                    return 0;
                    ;;
        hoisting) echo "stc.opt.hoist"
                    return 0
                    ;;
        disable-asserts) echo "stc.opt.disable-asserts"
                    return 0
                    ;;
        unroll-loops) echo "stc.opt.unroll-loops"
                    return 0
                    ;;

        array-switcheroo) echo "stc.array-ref-switcheroo"
                    return 0
                    ;;

        no-stack)   echo "stc.codegen.no-stack"
                    return 0
                    ;;
        no-stack-vars)
                    echo "stc.codegen.no-stack-vars"
                    return 0
                    ;;
        refcounting)
                    echo "stc.exp.refcounting"
                    return 0
                    ;;
       *)
         return 1
         ;;
    esac
}

function add_rpath() {
  verbose "RPATH: $1"
  rpath+=$1
}

function disable_opt() {
  local OPTNAME=$(get_compiler_opt_name $1)
  if [ -z "$OPTNAME" ]; then
    echo "ERROR Invalid compiler option $1" 1>&2
    return 1
  fi
  COMPILER_OPTS+="-D${OPTNAME}=false"
}

function enable_opt() {
  local OPTNAME=$(get_compiler_opt_name $1)
  if [ -z "$OPTNAME" ]; then
    echo "ERROR Invalid compiler option $1" 1>&2
    return 1
  fi
  COMPILER_OPTS+="-D${OPTNAME}=true"
}

help()
{
  cat ${STC_HOME}/help.txt
  exit 0
}

# Set this to 1 to debug this script (-V)
VERBOSE=0
verbose()
{
  if (( VERBOSE ))
  then
    print "stc: ${*}"
  fi
}

report_version()
{
  print "STC: Swift-Turbine Compiler"
  printf "\t for Turbine: "
  cat ${STC_HOME}/turbine-version.txt
  print "TURBINE_INSTALL=${TURBINE_INSTALL}"
  print "TURBINE_HOME=${TURBINE_HOME}"
  exit 0
}

while getopts "d:EhI:l:L:t:T:O:C:r:uvVx" OPTION
do
  case ${OPTION}
    in
    d) DEBUG_PORT=${OPTARG}
      verbose "DEBUG_PORT: ${DEBUG_PORT}"
      ;;
    E) OUTPUT_MODE=cpp
      ;;
    h)
      verbose "HELP:"
      help
      ;;
    I) CPP_INCLUDE+="-I ${OPTARG} "
      ;;
    l) LOGFILE=${OPTARG}
      verbose "LOGFILE: ${LOGFILE}"
      ;;
    L) LOGFILE=${OPTARG}
      verbose "LOGFILE: ${LOGFILE} trace enabled"
      LOGTRACE=true
      ;;
    r)
      add_rpath ${OPTARG}
      ;;
    t) verbose "TURNOFF: ${OPTARG}"
      disable_opt ${OPTARG}
      ;;
    T) verbose "TURNON: ${OPTARG}"
      enable_opt ${OPTARG}
      ;;
    O) verbose "Optimization level ${OPTARG}"
      if [ ${OPTARG} = 0 ]; then
        ENABLED_OPTS=()
        DISABLED_OPTS=($O1_OPTS $O2_OPTS $O3_OPTS $EXPERIMENTAL_OPTS)
      elif [ ${OPTARG} = 1 ]; then
        ENABLED_OPTS=($O1_OPTS)
        DISABLED_OPTS=($O2_OPTS $O3_OPTS $EXPERIMENTAL_OPTS)
      elif [ ${OPTARG} = 2 ]; then
        ENABLED_OPTS=($O1_OPTS $O2_OPTS)
        DISABLED_OPTS=($O3_OPTS $EXPERIMENTAL_OPTS)
      elif [ ${OPTARG} = 3 ]; then
        ENABLED_OPTS=($O1_OPTS $O2_OPTS $O3_OPTS)
        DISABLED_OPTS=($EXPERIMENTAL_OPTS)
      else
        echo "Invalid optimization level -O ${OPTARG}"
        return 1
      fi
      for opt in $DISABLED_OPTS; do
        disable_opt ${opt}
      done
      for opt in $ENABLED_OPTS; do
        enable_opt ${opt}
      done
      ;;
    C) verbose "IC Output: ${OPTARG}"
       COMPILER_OPTS+="-Dstc.ic.output-file=${OPTARG}"
       ;;
    u) UPDATE=1
      ;;
    v)
      report_version
      ;;
    V)
      (( VERBOSE )) && set -x
      VERBOSE=1
      ;;
    x)
      echo "Under construction"
      return ${EXIT_ERROR_SCRIPT}
      ;;
    *)
      # getopts already printed an error message
      return ${EXIT_ERROR_SCRIPT}
      ;;
  esac
done

shift $(( OPTIND-1 ))

# After shifting out the options we are left with the file names
INPUT=$1
# This is optional (defaults to stdout)
OUTPUT=$2

if [[ ${INPUT} == "" ]]
then
  print "stc: no input file"
  return ${EXIT_ERROR_SCRIPT}
fi

if [[ ! -f ${INPUT} ]]
then
  print "stc: not readable: ${INPUT}"
  return ${EXIT_ERROR_SCRIPT}
fi

# Clear this in case the user has set it
unset DEBUG
if [[ ${DEBUG_PORT} != "" ]]
then
  export DEBUG=-agentlib:jdwp=transport=dt_socket,server=y,address=${DEBUG_PORT}
fi

STDOUT=/dev/stdout
if [[ ${OUTPUT} == "" ]]
then
  OUTPUT=${STDOUT}
fi

# Check timestamps (-u)
if [[ ${UPDATE} == 1 && ${OUTPUT} != ${STDOUT} ]]
then
  if [[ -f ${OUTPUT} ]]
  then
    if [[ ${OUTPUT} -nt ${INPUT} ]]
    then
      # Output is up-to-date: done
      verbose "output is up-to-date."
      return 0
    fi
  fi
fi

ANTLR=${STC_HOME}/lib/antlr-3.4-complete-no-antlrv2.jar
STC=${STC_HOME}/lib/stc.jar
LOG4J=${STC_HOME}/lib/log4j-1.2.16.jar
CLASSPATH=${ANTLR}:${STC}:${LOG4J}

TURBINE_VERSION=$( < ${STC_HOME}/turbine-version.txt )

FLAGS=( -ea -Dstc.turbine.version=${TURBINE_VERSION} )
if [[ ${LOGFILE} != "" ]]
then
  FLAGS+="-Dstc.log.file=${LOGFILE}"
fi

if [[ ${LOGTRACE} = true ]]
then
  FLAGS+="-Dstc.log.trace=true"
fi

if [[ ${RPATH} != "" ]]
  then
  FLAGS+="-Dstc.rpath=${RPATH}"
fi

#FLAGS+="
# Check stc is compiled
if [[ ! -f ${STC} ]]
then
    print "Compiled STC jar not found at path ${STC}."
    print "Did you forget to compile STC?"
    return ${EXIT_ERROR_SCRIPT}
fi

# Find Turbine (for include path)
if [[ -z ${TURBINE_HOME} ]]
then
  if [[ -z ${TURBINE_INSTALL} ]]
  then
    print "Not set: TURBINE_HOME or TURBINE_INSTALL"
    return ${EXIT_ERROR_SCRIPT}
  else
    export TURBINE_HOME=${TURBINE_INSTALL}
  fi
fi

# Extra info flags
FLAGS+="-Dstc.input_filename=${INPUT}";
FLAGS+="-Dstc.output_filename=${OUTPUT}";
FLAGS+="-Dstc.stc_home=${STC_HOME}";
FLAGS+="-Dstc.turbine_home=${TURBINE_HOME}";

# Add last resort include paths
CPP_INCLUDE+="-I ${PWD} "
CPP_INCLUDE+="-I ${TURBINE_HOME}/export"

MAIN=exm.stc.ui.Main

JVM_FLAGS=()
# Increase stack size
JVM_FLAGS+="-Xss8m"
# Enable assertions
JVM_FLAGS+="-enableassertions"

# Group all JVM args together
ARGS="${JVM_FLAGS} ${DEBUG} ${FLAGS} ${COMPILER_OPTS} -cp ${CLASSPATH}"

# Assemble preprocessor command line
# We use gcc -E because cpp is broken on Mac GCC 4.2.1
#    Cf. http://stackoverflow.com/questions/4137923
CPP="gcc -E -x c ${CPP_INCLUDE}"

if [[ ${OUTPUT_MODE} == "cpp" ]]
then
  # Just preprocess
  ${=CPP} ${INPUT} > ${OUTPUT}
  return ${?}
fi

# We use ZSH to make a special file for the pre-processed script
java ${=ARGS} ${MAIN} <( ${=CPP} ${INPUT} ) ${OUTPUT}

EXITCODE=${?}

if (( EXITCODE ))
then
  # Compile did not succeed: remove output
  if [[ ${OUTPUT} != /dev* && -f ${OUTPUT} ]]
  then
    rm ${OUTPUT}
  fi
fi

# Return the exit code from the java process
return ${EXITCODE}
